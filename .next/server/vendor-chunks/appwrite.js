"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/appwrite";
exports.ids = ["vendor-chunks/appwrite"];
exports.modules = {

/***/ "(ssr)/./node_modules/appwrite/dist/esm/sdk.js":
/*!***********************************************!*\
  !*** ./node_modules/appwrite/dist/esm/sdk.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* binding */ Account),\n/* harmony export */   AppwriteException: () => (/* binding */ AppwriteException),\n/* harmony export */   AuthenticationFactor: () => (/* binding */ AuthenticationFactor),\n/* harmony export */   AuthenticatorType: () => (/* binding */ AuthenticatorType),\n/* harmony export */   Avatars: () => (/* binding */ Avatars),\n/* harmony export */   Browser: () => (/* binding */ Browser),\n/* harmony export */   Client: () => (/* binding */ Client),\n/* harmony export */   CreditCard: () => (/* binding */ CreditCard),\n/* harmony export */   Databases: () => (/* binding */ Databases),\n/* harmony export */   ExecutionMethod: () => (/* binding */ ExecutionMethod),\n/* harmony export */   Flag: () => (/* binding */ Flag),\n/* harmony export */   Functions: () => (/* binding */ Functions),\n/* harmony export */   Graphql: () => (/* binding */ Graphql),\n/* harmony export */   ID: () => (/* binding */ ID),\n/* harmony export */   ImageFormat: () => (/* binding */ ImageFormat),\n/* harmony export */   ImageGravity: () => (/* binding */ ImageGravity),\n/* harmony export */   Locale: () => (/* binding */ Locale),\n/* harmony export */   Messaging: () => (/* binding */ Messaging),\n/* harmony export */   OAuthProvider: () => (/* binding */ OAuthProvider),\n/* harmony export */   Permission: () => (/* binding */ Permission),\n/* harmony export */   Query: () => (/* binding */ Query),\n/* harmony export */   Role: () => (/* binding */ Role),\n/* harmony export */   Storage: () => (/* binding */ Storage),\n/* harmony export */   TablesDB: () => (/* binding */ TablesDB),\n/* harmony export */   Teams: () => (/* binding */ Teams)\n/* harmony export */ });\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\n\n/**\n * Helper class to generate query strings.\n */\nclass Query {\n    /**\n     * Constructor for Query class.\n     *\n     * @param {string} method\n     * @param {AttributesTypes} attribute\n     * @param {QueryTypes} values\n     */\n    constructor(method, attribute, values) {\n        this.method = method;\n        this.attribute = attribute;\n        if (values !== undefined) {\n            if (Array.isArray(values)) {\n                this.values = values;\n            }\n            else {\n                this.values = [values];\n            }\n        }\n    }\n    /**\n     * Convert the query object to a JSON string.\n     *\n     * @returns {string}\n     */\n    toString() {\n        return JSON.stringify({\n            method: this.method,\n            attribute: this.attribute,\n            values: this.values,\n        });\n    }\n}\n/**\n * Filter resources where attribute is equal to value.\n *\n * @param {string} attribute\n * @param {QueryTypes} value\n * @returns {string}\n */\nQuery.equal = (attribute, value) => new Query(\"equal\", attribute, value).toString();\n/**\n * Filter resources where attribute is not equal to value.\n *\n * @param {string} attribute\n * @param {QueryTypes} value\n * @returns {string}\n */\nQuery.notEqual = (attribute, value) => new Query(\"notEqual\", attribute, value).toString();\n/**\n * Filter resources where attribute is less than value.\n *\n * @param {string} attribute\n * @param {QueryTypes} value\n * @returns {string}\n */\nQuery.lessThan = (attribute, value) => new Query(\"lessThan\", attribute, value).toString();\n/**\n * Filter resources where attribute is less than or equal to value.\n *\n * @param {string} attribute\n * @param {QueryTypes} value\n * @returns {string}\n */\nQuery.lessThanEqual = (attribute, value) => new Query(\"lessThanEqual\", attribute, value).toString();\n/**\n * Filter resources where attribute is greater than value.\n *\n * @param {string} attribute\n * @param {QueryTypes} value\n * @returns {string}\n */\nQuery.greaterThan = (attribute, value) => new Query(\"greaterThan\", attribute, value).toString();\n/**\n * Filter resources where attribute is greater than or equal to value.\n *\n * @param {string} attribute\n * @param {QueryTypes} value\n * @returns {string}\n */\nQuery.greaterThanEqual = (attribute, value) => new Query(\"greaterThanEqual\", attribute, value).toString();\n/**\n * Filter resources where attribute is null.\n *\n * @param {string} attribute\n * @returns {string}\n */\nQuery.isNull = (attribute) => new Query(\"isNull\", attribute).toString();\n/**\n * Filter resources where attribute is not null.\n *\n * @param {string} attribute\n * @returns {string}\n */\nQuery.isNotNull = (attribute) => new Query(\"isNotNull\", attribute).toString();\n/**\n * Filter resources where attribute is between start and end (inclusive).\n *\n * @param {string} attribute\n * @param {string | number} start\n * @param {string | number} end\n * @returns {string}\n */\nQuery.between = (attribute, start, end) => new Query(\"between\", attribute, [start, end]).toString();\n/**\n * Filter resources where attribute starts with value.\n *\n * @param {string} attribute\n * @param {string} value\n * @returns {string}\n */\nQuery.startsWith = (attribute, value) => new Query(\"startsWith\", attribute, value).toString();\n/**\n * Filter resources where attribute ends with value.\n *\n * @param {string} attribute\n * @param {string} value\n * @returns {string}\n */\nQuery.endsWith = (attribute, value) => new Query(\"endsWith\", attribute, value).toString();\n/**\n * Specify which attributes should be returned by the API call.\n *\n * @param {string[]} attributes\n * @returns {string}\n */\nQuery.select = (attributes) => new Query(\"select\", undefined, attributes).toString();\n/**\n * Filter resources by searching attribute for value.\n * A fulltext index on attribute is required for this query to work.\n *\n * @param {string} attribute\n * @param {string} value\n * @returns {string}\n */\nQuery.search = (attribute, value) => new Query(\"search\", attribute, value).toString();\n/**\n * Sort results by attribute descending.\n *\n * @param {string} attribute\n * @returns {string}\n */\nQuery.orderDesc = (attribute) => new Query(\"orderDesc\", attribute).toString();\n/**\n * Sort results by attribute ascending.\n *\n * @param {string} attribute\n * @returns {string}\n */\nQuery.orderAsc = (attribute) => new Query(\"orderAsc\", attribute).toString();\n/**\n * Sort results randomly.\n *\n * @returns {string}\n */\nQuery.orderRandom = () => new Query(\"orderRandom\").toString();\n/**\n * Return results after documentId.\n *\n * @param {string} documentId\n * @returns {string}\n */\nQuery.cursorAfter = (documentId) => new Query(\"cursorAfter\", undefined, documentId).toString();\n/**\n * Return results before documentId.\n *\n * @param {string} documentId\n * @returns {string}\n */\nQuery.cursorBefore = (documentId) => new Query(\"cursorBefore\", undefined, documentId).toString();\n/**\n * Return only limit results.\n *\n * @param {number} limit\n * @returns {string}\n */\nQuery.limit = (limit) => new Query(\"limit\", undefined, limit).toString();\n/**\n * Filter resources by skipping the first offset results.\n *\n * @param {number} offset\n * @returns {string}\n */\nQuery.offset = (offset) => new Query(\"offset\", undefined, offset).toString();\n/**\n * Filter resources where attribute contains the specified value.\n *\n * @param {string} attribute\n * @param {string | string[]} value\n * @returns {string}\n */\nQuery.contains = (attribute, value) => new Query(\"contains\", attribute, value).toString();\n/**\n * Filter resources where attribute does not contain the specified value.\n *\n * @param {string} attribute\n * @param {string | any[]} value\n * @returns {string}\n */\nQuery.notContains = (attribute, value) => new Query(\"notContains\", attribute, value).toString();\n/**\n * Filter resources by searching attribute for value (inverse of search).\n * A fulltext index on attribute is required for this query to work.\n *\n * @param {string} attribute\n * @param {string} value\n * @returns {string}\n */\nQuery.notSearch = (attribute, value) => new Query(\"notSearch\", attribute, value).toString();\n/**\n * Filter resources where attribute is not between start and end (exclusive).\n *\n * @param {string} attribute\n * @param {string | number} start\n * @param {string | number} end\n * @returns {string}\n */\nQuery.notBetween = (attribute, start, end) => new Query(\"notBetween\", attribute, [start, end]).toString();\n/**\n * Filter resources where attribute does not start with value.\n *\n * @param {string} attribute\n * @param {string} value\n * @returns {string}\n */\nQuery.notStartsWith = (attribute, value) => new Query(\"notStartsWith\", attribute, value).toString();\n/**\n * Filter resources where attribute does not end with value.\n *\n * @param {string} attribute\n * @param {string} value\n * @returns {string}\n */\nQuery.notEndsWith = (attribute, value) => new Query(\"notEndsWith\", attribute, value).toString();\n/**\n * Filter resources where document was created before date.\n *\n * @param {string} value\n * @returns {string}\n */\nQuery.createdBefore = (value) => new Query(\"createdBefore\", undefined, value).toString();\n/**\n * Filter resources where document was created after date.\n *\n * @param {string} value\n * @returns {string}\n */\nQuery.createdAfter = (value) => new Query(\"createdAfter\", undefined, value).toString();\n/**\n * Filter resources where document was created between dates.\n *\n * @param {string} start\n * @param {string} end\n * @returns {string}\n */\nQuery.createdBetween = (start, end) => new Query(\"createdBetween\", undefined, [start, end]).toString();\n/**\n * Filter resources where document was updated before date.\n *\n * @param {string} value\n * @returns {string}\n */\nQuery.updatedBefore = (value) => new Query(\"updatedBefore\", undefined, value).toString();\n/**\n * Filter resources where document was updated after date.\n *\n * @param {string} value\n * @returns {string}\n */\nQuery.updatedAfter = (value) => new Query(\"updatedAfter\", undefined, value).toString();\n/**\n * Filter resources where document was updated between dates.\n *\n * @param {string} start\n * @param {string} end\n * @returns {string}\n */\nQuery.updatedBetween = (start, end) => new Query(\"updatedBetween\", undefined, [start, end]).toString();\n/**\n * Combine multiple queries using logical OR operator.\n *\n * @param {string[]} queries\n * @returns {string}\n */\nQuery.or = (queries) => new Query(\"or\", undefined, queries.map((query) => JSON.parse(query))).toString();\n/**\n * Combine multiple queries using logical AND operator.\n *\n * @param {string[]} queries\n * @returns {string}\n */\nQuery.and = (queries) => new Query(\"and\", undefined, queries.map((query) => JSON.parse(query))).toString();\n/**\n * Filter resources where attribute is at a specific distance from the given coordinates.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @param {number} distance\n * @param {boolean} meters\n * @returns {string}\n */\nQuery.distanceEqual = (attribute, values, distance, meters = true) => new Query(\"distanceEqual\", attribute, [[values, distance, meters]]).toString();\n/**\n * Filter resources where attribute is not at a specific distance from the given coordinates.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @param {number} distance\n * @param {boolean} meters\n * @returns {string}\n */\nQuery.distanceNotEqual = (attribute, values, distance, meters = true) => new Query(\"distanceNotEqual\", attribute, [[values, distance, meters]]).toString();\n/**\n * Filter resources where attribute is at a distance greater than the specified value from the given coordinates.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @param {number} distance\n * @param {boolean} meters\n * @returns {string}\n */\nQuery.distanceGreaterThan = (attribute, values, distance, meters = true) => new Query(\"distanceGreaterThan\", attribute, [[values, distance, meters]]).toString();\n/**\n * Filter resources where attribute is at a distance less than the specified value from the given coordinates.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @param {number} distance\n * @param {boolean} meters\n * @returns {string}\n */\nQuery.distanceLessThan = (attribute, values, distance, meters = true) => new Query(\"distanceLessThan\", attribute, [[values, distance, meters]]).toString();\n/**\n * Filter resources where attribute intersects with the given geometry.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @returns {string}\n */\nQuery.intersects = (attribute, values) => new Query(\"intersects\", attribute, [values]).toString();\n/**\n * Filter resources where attribute does not intersect with the given geometry.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @returns {string}\n */\nQuery.notIntersects = (attribute, values) => new Query(\"notIntersects\", attribute, [values]).toString();\n/**\n * Filter resources where attribute crosses the given geometry.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @returns {string}\n */\nQuery.crosses = (attribute, values) => new Query(\"crosses\", attribute, [values]).toString();\n/**\n * Filter resources where attribute does not cross the given geometry.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @returns {string}\n */\nQuery.notCrosses = (attribute, values) => new Query(\"notCrosses\", attribute, [values]).toString();\n/**\n * Filter resources where attribute overlaps with the given geometry.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @returns {string}\n */\nQuery.overlaps = (attribute, values) => new Query(\"overlaps\", attribute, [values]).toString();\n/**\n * Filter resources where attribute does not overlap with the given geometry.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @returns {string}\n */\nQuery.notOverlaps = (attribute, values) => new Query(\"notOverlaps\", attribute, [values]).toString();\n/**\n * Filter resources where attribute touches the given geometry.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @returns {string}\n */\nQuery.touches = (attribute, values) => new Query(\"touches\", attribute, [values]).toString();\n/**\n * Filter resources where attribute does not touch the given geometry.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @returns {string}\n */\nQuery.notTouches = (attribute, values) => new Query(\"notTouches\", attribute, [values]).toString();\n\n/**\n * Exception thrown by the  package\n */\nclass AppwriteException extends Error {\n    /**\n     * Initializes a Appwrite Exception.\n     *\n     * @param {string} message - The error message.\n     * @param {number} code - The error code. Default is 0.\n     * @param {string} type - The error type. Default is an empty string.\n     * @param {string} response - The response string. Default is an empty string.\n     */\n    constructor(message, code = 0, type = '', response = '') {\n        super(message);\n        this.name = 'AppwriteException';\n        this.message = message;\n        this.code = code;\n        this.type = type;\n        this.response = response;\n    }\n}\n/**\n * Client that handles requests to Appwrite\n */\nclass Client {\n    constructor() {\n        /**\n         * Holds configuration such as project.\n         */\n        this.config = {\n            endpoint: 'https://cloud.appwrite.io/v1',\n            endpointRealtime: '',\n            project: '',\n            jwt: '',\n            locale: '',\n            session: '',\n            devkey: '',\n        };\n        /**\n         * Custom headers for API requests.\n         */\n        this.headers = {\n            'x-sdk-name': 'Web',\n            'x-sdk-platform': 'client',\n            'x-sdk-language': 'web',\n            'x-sdk-version': '21.0.0',\n            'X-Appwrite-Response-Format': '1.8.0',\n        };\n        this.realtime = {\n            socket: undefined,\n            timeout: undefined,\n            heartbeat: undefined,\n            url: '',\n            channels: new Set(),\n            subscriptions: new Map(),\n            subscriptionsCounter: 0,\n            reconnect: true,\n            reconnectAttempts: 0,\n            lastMessage: undefined,\n            connect: () => {\n                clearTimeout(this.realtime.timeout);\n                this.realtime.timeout = window === null || window === void 0 ? void 0 : window.setTimeout(() => {\n                    this.realtime.createSocket();\n                }, 50);\n            },\n            getTimeout: () => {\n                switch (true) {\n                    case this.realtime.reconnectAttempts < 5:\n                        return 1000;\n                    case this.realtime.reconnectAttempts < 15:\n                        return 5000;\n                    case this.realtime.reconnectAttempts < 100:\n                        return 10000;\n                    default:\n                        return 60000;\n                }\n            },\n            createHeartbeat: () => {\n                if (this.realtime.heartbeat) {\n                    clearTimeout(this.realtime.heartbeat);\n                }\n                this.realtime.heartbeat = window === null || window === void 0 ? void 0 : window.setInterval(() => {\n                    var _a;\n                    (_a = this.realtime.socket) === null || _a === void 0 ? void 0 : _a.send(JSON.stringify({\n                        type: 'ping'\n                    }));\n                }, 20000);\n            },\n            createSocket: () => {\n                var _a, _b, _c;\n                if (this.realtime.channels.size < 1) {\n                    this.realtime.reconnect = false;\n                    (_a = this.realtime.socket) === null || _a === void 0 ? void 0 : _a.close();\n                    return;\n                }\n                const channels = new URLSearchParams();\n                channels.set('project', this.config.project);\n                this.realtime.channels.forEach(channel => {\n                    channels.append('channels[]', channel);\n                });\n                const url = this.config.endpointRealtime + '/realtime?' + channels.toString();\n                if (url !== this.realtime.url || // Check if URL is present\n                    !this.realtime.socket || // Check if WebSocket has not been created\n                    ((_b = this.realtime.socket) === null || _b === void 0 ? void 0 : _b.readyState) > WebSocket.OPEN // Check if WebSocket is CLOSING (3) or CLOSED (4)\n                ) {\n                    if (this.realtime.socket &&\n                        ((_c = this.realtime.socket) === null || _c === void 0 ? void 0 : _c.readyState) < WebSocket.CLOSING // Close WebSocket if it is CONNECTING (0) or OPEN (1)\n                    ) {\n                        this.realtime.reconnect = false;\n                        this.realtime.socket.close();\n                    }\n                    this.realtime.url = url;\n                    this.realtime.socket = new WebSocket(url);\n                    this.realtime.socket.addEventListener('message', this.realtime.onMessage);\n                    this.realtime.socket.addEventListener('open', _event => {\n                        this.realtime.reconnectAttempts = 0;\n                        this.realtime.createHeartbeat();\n                    });\n                    this.realtime.socket.addEventListener('close', event => {\n                        var _a, _b, _c;\n                        if (!this.realtime.reconnect ||\n                            (((_b = (_a = this.realtime) === null || _a === void 0 ? void 0 : _a.lastMessage) === null || _b === void 0 ? void 0 : _b.type) === 'error' && // Check if last message was of type error\n                                ((_c = this.realtime) === null || _c === void 0 ? void 0 : _c.lastMessage.data).code === 1008 // Check for policy violation 1008\n                            )) {\n                            this.realtime.reconnect = true;\n                            return;\n                        }\n                        const timeout = this.realtime.getTimeout();\n                        console.error(`Realtime got disconnected. Reconnect will be attempted in ${timeout / 1000} seconds.`, event.reason);\n                        setTimeout(() => {\n                            this.realtime.reconnectAttempts++;\n                            this.realtime.createSocket();\n                        }, timeout);\n                    });\n                }\n            },\n            onMessage: (event) => {\n                var _a, _b;\n                try {\n                    const message = JSON.parse(event.data);\n                    this.realtime.lastMessage = message;\n                    switch (message.type) {\n                        case 'connected':\n                            const cookie = JSON.parse((_a = window.localStorage.getItem('cookieFallback')) !== null && _a !== void 0 ? _a : '{}');\n                            const session = cookie === null || cookie === void 0 ? void 0 : cookie[`a_session_${this.config.project}`];\n                            const messageData = message.data;\n                            if (session && !messageData.user) {\n                                (_b = this.realtime.socket) === null || _b === void 0 ? void 0 : _b.send(JSON.stringify({\n                                    type: 'authentication',\n                                    data: {\n                                        session\n                                    }\n                                }));\n                            }\n                            break;\n                        case 'event':\n                            let data = message.data;\n                            if (data === null || data === void 0 ? void 0 : data.channels) {\n                                const isSubscribed = data.channels.some(channel => this.realtime.channels.has(channel));\n                                if (!isSubscribed)\n                                    return;\n                                this.realtime.subscriptions.forEach(subscription => {\n                                    if (data.channels.some(channel => subscription.channels.includes(channel))) {\n                                        setTimeout(() => subscription.callback(data));\n                                    }\n                                });\n                            }\n                            break;\n                        case 'pong':\n                            break; // Handle pong response if needed\n                        case 'error':\n                            throw message.data;\n                        default:\n                            break;\n                    }\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            },\n            cleanUp: channels => {\n                this.realtime.channels.forEach(channel => {\n                    if (channels.includes(channel)) {\n                        let found = Array.from(this.realtime.subscriptions).some(([_key, subscription]) => {\n                            return subscription.channels.includes(channel);\n                        });\n                        if (!found) {\n                            this.realtime.channels.delete(channel);\n                        }\n                    }\n                });\n            }\n        };\n    }\n    /**\n     * Set Endpoint\n     *\n     * Your project endpoint\n     *\n     * @param {string} endpoint\n     *\n     * @returns {this}\n     */\n    setEndpoint(endpoint) {\n        if (!endpoint.startsWith('http://') && !endpoint.startsWith('https://')) {\n            throw new AppwriteException('Invalid endpoint URL: ' + endpoint);\n        }\n        this.config.endpoint = endpoint;\n        this.config.endpointRealtime = endpoint.replace('https://', 'wss://').replace('http://', 'ws://');\n        return this;\n    }\n    /**\n     * Set Realtime Endpoint\n     *\n     * @param {string} endpointRealtime\n     *\n     * @returns {this}\n     */\n    setEndpointRealtime(endpointRealtime) {\n        if (!endpointRealtime.startsWith('ws://') && !endpointRealtime.startsWith('wss://')) {\n            throw new AppwriteException('Invalid realtime endpoint URL: ' + endpointRealtime);\n        }\n        this.config.endpointRealtime = endpointRealtime;\n        return this;\n    }\n    /**\n     * Set Project\n     *\n     * Your project ID\n     *\n     * @param value string\n     *\n     * @return {this}\n     */\n    setProject(value) {\n        this.headers['X-Appwrite-Project'] = value;\n        this.config.project = value;\n        return this;\n    }\n    /**\n     * Set JWT\n     *\n     * Your secret JSON Web Token\n     *\n     * @param value string\n     *\n     * @return {this}\n     */\n    setJWT(value) {\n        this.headers['X-Appwrite-JWT'] = value;\n        this.config.jwt = value;\n        return this;\n    }\n    /**\n     * Set Locale\n     *\n     * @param value string\n     *\n     * @return {this}\n     */\n    setLocale(value) {\n        this.headers['X-Appwrite-Locale'] = value;\n        this.config.locale = value;\n        return this;\n    }\n    /**\n     * Set Session\n     *\n     * The user session to authenticate with\n     *\n     * @param value string\n     *\n     * @return {this}\n     */\n    setSession(value) {\n        this.headers['X-Appwrite-Session'] = value;\n        this.config.session = value;\n        return this;\n    }\n    /**\n     * Set DevKey\n     *\n     * Your secret dev API key\n     *\n     * @param value string\n     *\n     * @return {this}\n     */\n    setDevKey(value) {\n        this.headers['X-Appwrite-Dev-Key'] = value;\n        this.config.devkey = value;\n        return this;\n    }\n    /**\n     * Subscribes to Appwrite events and passes you the payload in realtime.\n     *\n     * @param {string|string[]} channels\n     * Channel to subscribe - pass a single channel as a string or multiple with an array of strings.\n     *\n     * Possible channels are:\n     * - account\n     * - collections\n     * - collections.[ID]\n     * - collections.[ID].documents\n     * - documents\n     * - documents.[ID]\n     * - files\n     * - files.[ID]\n     * - executions\n     * - executions.[ID]\n     * - functions.[ID]\n     * - teams\n     * - teams.[ID]\n     * - memberships\n     * - memberships.[ID]\n     * @param {(payload: RealtimeMessage) => void} callback Is called on every realtime update.\n     * @returns {() => void} Unsubscribes from events.\n     */\n    subscribe(channels, callback) {\n        let channelArray = typeof channels === 'string' ? [channels] : channels;\n        channelArray.forEach(channel => this.realtime.channels.add(channel));\n        const counter = this.realtime.subscriptionsCounter++;\n        this.realtime.subscriptions.set(counter, {\n            channels: channelArray,\n            callback\n        });\n        this.realtime.connect();\n        return () => {\n            this.realtime.subscriptions.delete(counter);\n            this.realtime.cleanUp(channelArray);\n            this.realtime.connect();\n        };\n    }\n    prepareRequest(method, url, headers = {}, params = {}) {\n        method = method.toUpperCase();\n        headers = Object.assign({}, this.headers, headers);\n        if (typeof window !== 'undefined' && window.localStorage) {\n            const cookieFallback = window.localStorage.getItem('cookieFallback');\n            if (cookieFallback) {\n                headers['X-Fallback-Cookies'] = cookieFallback;\n            }\n        }\n        let options = {\n            method,\n            headers,\n        };\n        if (headers['X-Appwrite-Dev-Key'] === undefined) {\n            options.credentials = 'include';\n        }\n        if (method === 'GET') {\n            for (const [key, value] of Object.entries(Client.flatten(params))) {\n                url.searchParams.append(key, value);\n            }\n        }\n        else {\n            switch (headers['content-type']) {\n                case 'application/json':\n                    options.body = JSON.stringify(params);\n                    break;\n                case 'multipart/form-data':\n                    const formData = new FormData();\n                    for (const [key, value] of Object.entries(params)) {\n                        if (value instanceof File) {\n                            formData.append(key, value, value.name);\n                        }\n                        else if (Array.isArray(value)) {\n                            for (const nestedValue of value) {\n                                formData.append(`${key}[]`, nestedValue);\n                            }\n                        }\n                        else {\n                            formData.append(key, value);\n                        }\n                    }\n                    options.body = formData;\n                    delete headers['content-type'];\n                    break;\n            }\n        }\n        return { uri: url.toString(), options };\n    }\n    chunkedUpload(method, url, headers = {}, originalPayload = {}, onProgress) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const [fileParam, file] = (_a = Object.entries(originalPayload).find(([_, value]) => value instanceof File)) !== null && _a !== void 0 ? _a : [];\n            if (!file || !fileParam) {\n                throw new Error('File not found in payload');\n            }\n            if (file.size <= Client.CHUNK_SIZE) {\n                return yield this.call(method, url, headers, originalPayload);\n            }\n            let start = 0;\n            let response = null;\n            while (start < file.size) {\n                let end = start + Client.CHUNK_SIZE; // Prepare end for the next chunk\n                if (end >= file.size) {\n                    end = file.size; // Adjust for the last chunk to include the last byte\n                }\n                headers['content-range'] = `bytes ${start}-${end - 1}/${file.size}`;\n                const chunk = file.slice(start, end);\n                let payload = Object.assign({}, originalPayload);\n                payload[fileParam] = new File([chunk], file.name);\n                response = yield this.call(method, url, headers, payload);\n                if (onProgress && typeof onProgress === 'function') {\n                    onProgress({\n                        $id: response.$id,\n                        progress: Math.round((end / file.size) * 100),\n                        sizeUploaded: end,\n                        chunksTotal: Math.ceil(file.size / Client.CHUNK_SIZE),\n                        chunksUploaded: Math.ceil(end / Client.CHUNK_SIZE)\n                    });\n                }\n                if (response && response.$id) {\n                    headers['x-appwrite-id'] = response.$id;\n                }\n                start = end;\n            }\n            return response;\n        });\n    }\n    ping() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.call('GET', new URL(this.config.endpoint + '/ping'));\n        });\n    }\n    call(method, url, headers = {}, params = {}, responseType = 'json') {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            const { uri, options } = this.prepareRequest(method, url, headers, params);\n            let data = null;\n            const response = yield fetch(uri, options);\n            // type opaque: No-CORS, different-origin response (CORS-issue)\n            if (response.type === 'opaque') {\n                throw new AppwriteException(`Invalid Origin. Register your new client (${window.location.host}) as a new Web platform on your project console dashboard`, 403, \"forbidden\", \"\");\n            }\n            const warnings = response.headers.get('x-appwrite-warning');\n            if (warnings) {\n                warnings.split(';').forEach((warning) => console.warn('Warning: ' + warning));\n            }\n            if ((_a = response.headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.includes('application/json')) {\n                data = yield response.json();\n            }\n            else if (responseType === 'arrayBuffer') {\n                data = yield response.arrayBuffer();\n            }\n            else {\n                data = {\n                    message: yield response.text()\n                };\n            }\n            if (400 <= response.status) {\n                let responseText = '';\n                if (((_b = response.headers.get('content-type')) === null || _b === void 0 ? void 0 : _b.includes('application/json')) || responseType === 'arrayBuffer') {\n                    responseText = JSON.stringify(data);\n                }\n                else {\n                    responseText = data === null || data === void 0 ? void 0 : data.message;\n                }\n                throw new AppwriteException(data === null || data === void 0 ? void 0 : data.message, response.status, data === null || data === void 0 ? void 0 : data.type, responseText);\n            }\n            const cookieFallback = response.headers.get('X-Fallback-Cookies');\n            if (typeof window !== 'undefined' && window.localStorage && cookieFallback) {\n                window.console.warn('Appwrite is using localStorage for session management. Increase your security by adding a custom domain as your API endpoint.');\n                window.localStorage.setItem('cookieFallback', cookieFallback);\n            }\n            return data;\n        });\n    }\n    static flatten(data, prefix = '') {\n        let output = {};\n        for (const [key, value] of Object.entries(data)) {\n            let finalKey = prefix ? prefix + '[' + key + ']' : key;\n            if (Array.isArray(value)) {\n                output = Object.assign(Object.assign({}, output), Client.flatten(value, finalKey));\n            }\n            else {\n                output[finalKey] = value;\n            }\n        }\n        return output;\n    }\n}\nClient.CHUNK_SIZE = 1024 * 1024 * 5;\n\nclass Service {\n    constructor(client) {\n        this.client = client;\n    }\n    static flatten(data, prefix = '') {\n        let output = {};\n        for (const [key, value] of Object.entries(data)) {\n            let finalKey = prefix ? prefix + '[' + key + ']' : key;\n            if (Array.isArray(value)) {\n                output = Object.assign(Object.assign({}, output), Service.flatten(value, finalKey));\n            }\n            else {\n                output[finalKey] = value;\n            }\n        }\n        return output;\n    }\n}\n/**\n * The size for chunked uploads in bytes.\n */\nService.CHUNK_SIZE = 5 * 1024 * 1024; // 5MB\n\nclass Account {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Get the currently logged in user.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.User<Preferences>>}\n     */\n    get() {\n        const apiPath = '/account';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    create(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                email: rest[0],\n                password: rest[1],\n                name: rest[2]\n            };\n        }\n        const userId = params.userId;\n        const email = params.email;\n        const password = params.password;\n        const name = params.name;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        const apiPath = '/account';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    updateEmail(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                email: paramsOrFirst,\n                password: rest[0]\n            };\n        }\n        const email = params.email;\n        const password = params.password;\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        const apiPath = '/account/email';\n        const payload = {};\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    listIdentities(paramsOrFirst) {\n        let params;\n        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                queries: paramsOrFirst\n            };\n        }\n        const queries = params.queries;\n        const apiPath = '/account/identities';\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    deleteIdentity(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                identityId: paramsOrFirst\n            };\n        }\n        const identityId = params.identityId;\n        if (typeof identityId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"identityId\"');\n        }\n        const apiPath = '/account/identities/{identityId}'.replace('{identityId}', identityId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    /**\n     * Use this endpoint to create a JSON Web Token. You can use the resulting JWT to authenticate on behalf of the current user when working with the Appwrite server-side API and SDKs. The JWT secret is valid for 15 minutes from its creation and will be invalid if the user will logout in that time frame.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Jwt>}\n     */\n    createJWT() {\n        const apiPath = '/account/jwts';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    listLogs(paramsOrFirst) {\n        let params;\n        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                queries: paramsOrFirst\n            };\n        }\n        const queries = params.queries;\n        const apiPath = '/account/logs';\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    updateMFA(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                mfa: paramsOrFirst\n            };\n        }\n        const mfa = params.mfa;\n        if (typeof mfa === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"mfa\"');\n        }\n        const apiPath = '/account/mfa';\n        const payload = {};\n        if (typeof mfa !== 'undefined') {\n            payload['mfa'] = mfa;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    createMfaAuthenticator(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'type' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                type: paramsOrFirst\n            };\n        }\n        const type = params.type;\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    createMFAAuthenticator(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'type' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                type: paramsOrFirst\n            };\n        }\n        const type = params.type;\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    updateMfaAuthenticator(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'type' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                type: paramsOrFirst,\n                otp: rest[0]\n            };\n        }\n        const type = params.type;\n        const otp = params.otp;\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n        if (typeof otp === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"otp\"');\n        }\n        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);\n        const payload = {};\n        if (typeof otp !== 'undefined') {\n            payload['otp'] = otp;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    updateMFAAuthenticator(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'type' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                type: paramsOrFirst,\n                otp: rest[0]\n            };\n        }\n        const type = params.type;\n        const otp = params.otp;\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n        if (typeof otp === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"otp\"');\n        }\n        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);\n        const payload = {};\n        if (typeof otp !== 'undefined') {\n            payload['otp'] = otp;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    deleteMfaAuthenticator(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'type' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                type: paramsOrFirst\n            };\n        }\n        const type = params.type;\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    deleteMFAAuthenticator(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'type' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                type: paramsOrFirst\n            };\n        }\n        const type = params.type;\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    createMfaChallenge(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'factor' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                factor: paramsOrFirst\n            };\n        }\n        const factor = params.factor;\n        if (typeof factor === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"factor\"');\n        }\n        const apiPath = '/account/mfa/challenge';\n        const payload = {};\n        if (typeof factor !== 'undefined') {\n            payload['factor'] = factor;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    createMFAChallenge(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'factor' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                factor: paramsOrFirst\n            };\n        }\n        const factor = params.factor;\n        if (typeof factor === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"factor\"');\n        }\n        const apiPath = '/account/mfa/challenge';\n        const payload = {};\n        if (typeof factor !== 'undefined') {\n            payload['factor'] = factor;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    updateMfaChallenge(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                challengeId: paramsOrFirst,\n                otp: rest[0]\n            };\n        }\n        const challengeId = params.challengeId;\n        const otp = params.otp;\n        if (typeof challengeId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"challengeId\"');\n        }\n        if (typeof otp === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"otp\"');\n        }\n        const apiPath = '/account/mfa/challenge';\n        const payload = {};\n        if (typeof challengeId !== 'undefined') {\n            payload['challengeId'] = challengeId;\n        }\n        if (typeof otp !== 'undefined') {\n            payload['otp'] = otp;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    updateMFAChallenge(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                challengeId: paramsOrFirst,\n                otp: rest[0]\n            };\n        }\n        const challengeId = params.challengeId;\n        const otp = params.otp;\n        if (typeof challengeId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"challengeId\"');\n        }\n        if (typeof otp === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"otp\"');\n        }\n        const apiPath = '/account/mfa/challenge';\n        const payload = {};\n        if (typeof challengeId !== 'undefined') {\n            payload['challengeId'] = challengeId;\n        }\n        if (typeof otp !== 'undefined') {\n            payload['otp'] = otp;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    /**\n     * List the factors available on the account to be used as a MFA challange.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.MfaFactors>}\n     * @deprecated This API has been deprecated since 1.8.0. Please use `Account.listMFAFactors` instead.\n     */\n    listMfaFactors() {\n        const apiPath = '/account/mfa/factors';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * List the factors available on the account to be used as a MFA challange.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.MfaFactors>}\n     */\n    listMFAFactors() {\n        const apiPath = '/account/mfa/factors';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * Get recovery codes that can be used as backup for MFA flow. Before getting codes, they must be generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to read recovery codes.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.MfaRecoveryCodes>}\n     * @deprecated This API has been deprecated since 1.8.0. Please use `Account.getMFARecoveryCodes` instead.\n     */\n    getMfaRecoveryCodes() {\n        const apiPath = '/account/mfa/recovery-codes';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * Get recovery codes that can be used as backup for MFA flow. Before getting codes, they must be generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to read recovery codes.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.MfaRecoveryCodes>}\n     */\n    getMFARecoveryCodes() {\n        const apiPath = '/account/mfa/recovery-codes';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * Generate recovery codes as backup for MFA flow. It's recommended to generate and show then immediately after user successfully adds their authehticator. Recovery codes can be used as a MFA verification type in [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge) method.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.MfaRecoveryCodes>}\n     * @deprecated This API has been deprecated since 1.8.0. Please use `Account.createMFARecoveryCodes` instead.\n     */\n    createMfaRecoveryCodes() {\n        const apiPath = '/account/mfa/recovery-codes';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    /**\n     * Generate recovery codes as backup for MFA flow. It's recommended to generate and show then immediately after user successfully adds their authehticator. Recovery codes can be used as a MFA verification type in [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge) method.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.MfaRecoveryCodes>}\n     */\n    createMFARecoveryCodes() {\n        const apiPath = '/account/mfa/recovery-codes';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    /**\n     * Regenerate recovery codes that can be used as backup for MFA flow. Before regenerating codes, they must be first generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to regenreate recovery codes.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.MfaRecoveryCodes>}\n     * @deprecated This API has been deprecated since 1.8.0. Please use `Account.updateMFARecoveryCodes` instead.\n     */\n    updateMfaRecoveryCodes() {\n        const apiPath = '/account/mfa/recovery-codes';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    /**\n     * Regenerate recovery codes that can be used as backup for MFA flow. Before regenerating codes, they must be first generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to regenreate recovery codes.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.MfaRecoveryCodes>}\n     */\n    updateMFARecoveryCodes() {\n        const apiPath = '/account/mfa/recovery-codes';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    updateName(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                name: paramsOrFirst\n            };\n        }\n        const name = params.name;\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n        const apiPath = '/account/name';\n        const payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    updatePassword(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                password: paramsOrFirst,\n                oldPassword: rest[0]\n            };\n        }\n        const password = params.password;\n        const oldPassword = params.oldPassword;\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        const apiPath = '/account/password';\n        const payload = {};\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n        if (typeof oldPassword !== 'undefined') {\n            payload['oldPassword'] = oldPassword;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    updatePhone(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                phone: paramsOrFirst,\n                password: rest[0]\n            };\n        }\n        const phone = params.phone;\n        const password = params.password;\n        if (typeof phone === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"phone\"');\n        }\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        const apiPath = '/account/phone';\n        const payload = {};\n        if (typeof phone !== 'undefined') {\n            payload['phone'] = phone;\n        }\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    /**\n     * Get the preferences as a key-value object for the currently logged in user.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Preferences>}\n     */\n    getPrefs() {\n        const apiPath = '/account/prefs';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    updatePrefs(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'prefs' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                prefs: paramsOrFirst\n            };\n        }\n        const prefs = params.prefs;\n        if (typeof prefs === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"prefs\"');\n        }\n        const apiPath = '/account/prefs';\n        const payload = {};\n        if (typeof prefs !== 'undefined') {\n            payload['prefs'] = prefs;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    createRecovery(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                email: paramsOrFirst,\n                url: rest[0]\n            };\n        }\n        const email = params.email;\n        const url = params.url;\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n        if (typeof url === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n        const apiPath = '/account/recovery';\n        const payload = {};\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    updateRecovery(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                secret: rest[0],\n                password: rest[1]\n            };\n        }\n        const userId = params.userId;\n        const secret = params.secret;\n        const password = params.password;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        const apiPath = '/account/recovery';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    /**\n     * Get the list of active sessions across different devices for the currently logged in user.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.SessionList>}\n     */\n    listSessions() {\n        const apiPath = '/account/sessions';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * Delete all sessions from the user account and remove any sessions cookies from the end client.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<{}>}\n     */\n    deleteSessions() {\n        const apiPath = '/account/sessions';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    /**\n     * Use this endpoint to allow a new user to register an anonymous account in your project. This route will also create a new session for the user. To allow the new user to convert an anonymous account to a normal account, you need to update its [email and password](https://appwrite.io/docs/references/cloud/client-web/account#updateEmail) or create an [OAuth2 session](https://appwrite.io/docs/references/cloud/client-web/account#CreateOAuth2Session).\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Session>}\n     */\n    createAnonymousSession() {\n        const apiPath = '/account/sessions/anonymous';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    createEmailPasswordSession(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                email: paramsOrFirst,\n                password: rest[0]\n            };\n        }\n        const email = params.email;\n        const password = params.password;\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        const apiPath = '/account/sessions/email';\n        const payload = {};\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    updateMagicURLSession(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                secret: rest[0]\n            };\n        }\n        const userId = params.userId;\n        const secret = params.secret;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n        const apiPath = '/account/sessions/magic-url';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    createOAuth2Session(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'provider' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                provider: paramsOrFirst,\n                success: rest[0],\n                failure: rest[1],\n                scopes: rest[2]\n            };\n        }\n        const provider = params.provider;\n        const success = params.success;\n        const failure = params.failure;\n        const scopes = params.scopes;\n        if (typeof provider === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"provider\"');\n        }\n        const apiPath = '/account/sessions/oauth2/{provider}'.replace('{provider}', provider);\n        const payload = {};\n        if (typeof success !== 'undefined') {\n            payload['success'] = success;\n        }\n        if (typeof failure !== 'undefined') {\n            payload['failure'] = failure;\n        }\n        if (typeof scopes !== 'undefined') {\n            payload['scopes'] = scopes;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        if (typeof window !== 'undefined' && (window === null || window === void 0 ? void 0 : window.location)) {\n            window.location.href = uri.toString();\n            return;\n        }\n        else {\n            return uri.toString();\n        }\n    }\n    updatePhoneSession(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                secret: rest[0]\n            };\n        }\n        const userId = params.userId;\n        const secret = params.secret;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n        const apiPath = '/account/sessions/phone';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    createSession(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                secret: rest[0]\n            };\n        }\n        const userId = params.userId;\n        const secret = params.secret;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n        const apiPath = '/account/sessions/token';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    getSession(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                sessionId: paramsOrFirst\n            };\n        }\n        const sessionId = params.sessionId;\n        if (typeof sessionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"sessionId\"');\n        }\n        const apiPath = '/account/sessions/{sessionId}'.replace('{sessionId}', sessionId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    updateSession(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                sessionId: paramsOrFirst\n            };\n        }\n        const sessionId = params.sessionId;\n        if (typeof sessionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"sessionId\"');\n        }\n        const apiPath = '/account/sessions/{sessionId}'.replace('{sessionId}', sessionId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    deleteSession(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                sessionId: paramsOrFirst\n            };\n        }\n        const sessionId = params.sessionId;\n        if (typeof sessionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"sessionId\"');\n        }\n        const apiPath = '/account/sessions/{sessionId}'.replace('{sessionId}', sessionId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    /**\n     * Block the currently logged in user account. Behind the scene, the user record is not deleted but permanently blocked from any access. To completely delete a user, use the Users API instead.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.User<Preferences>>}\n     */\n    updateStatus() {\n        const apiPath = '/account/status';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    createPushTarget(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                targetId: paramsOrFirst,\n                identifier: rest[0],\n                providerId: rest[1]\n            };\n        }\n        const targetId = params.targetId;\n        const identifier = params.identifier;\n        const providerId = params.providerId;\n        if (typeof targetId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"targetId\"');\n        }\n        if (typeof identifier === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"identifier\"');\n        }\n        const apiPath = '/account/targets/push';\n        const payload = {};\n        if (typeof targetId !== 'undefined') {\n            payload['targetId'] = targetId;\n        }\n        if (typeof identifier !== 'undefined') {\n            payload['identifier'] = identifier;\n        }\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    updatePushTarget(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                targetId: paramsOrFirst,\n                identifier: rest[0]\n            };\n        }\n        const targetId = params.targetId;\n        const identifier = params.identifier;\n        if (typeof targetId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"targetId\"');\n        }\n        if (typeof identifier === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"identifier\"');\n        }\n        const apiPath = '/account/targets/{targetId}/push'.replace('{targetId}', targetId);\n        const payload = {};\n        if (typeof identifier !== 'undefined') {\n            payload['identifier'] = identifier;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    deletePushTarget(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                targetId: paramsOrFirst\n            };\n        }\n        const targetId = params.targetId;\n        if (typeof targetId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"targetId\"');\n        }\n        const apiPath = '/account/targets/{targetId}/push'.replace('{targetId}', targetId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    createEmailToken(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                email: rest[0],\n                phrase: rest[1]\n            };\n        }\n        const userId = params.userId;\n        const email = params.email;\n        const phrase = params.phrase;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n        const apiPath = '/account/tokens/email';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n        if (typeof phrase !== 'undefined') {\n            payload['phrase'] = phrase;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    createMagicURLToken(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                email: rest[0],\n                url: rest[1],\n                phrase: rest[2]\n            };\n        }\n        const userId = params.userId;\n        const email = params.email;\n        const url = params.url;\n        const phrase = params.phrase;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n        const apiPath = '/account/tokens/magic-url';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n        if (typeof phrase !== 'undefined') {\n            payload['phrase'] = phrase;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    createOAuth2Token(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'provider' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                provider: paramsOrFirst,\n                success: rest[0],\n                failure: rest[1],\n                scopes: rest[2]\n            };\n        }\n        const provider = params.provider;\n        const success = params.success;\n        const failure = params.failure;\n        const scopes = params.scopes;\n        if (typeof provider === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"provider\"');\n        }\n        const apiPath = '/account/tokens/oauth2/{provider}'.replace('{provider}', provider);\n        const payload = {};\n        if (typeof success !== 'undefined') {\n            payload['success'] = success;\n        }\n        if (typeof failure !== 'undefined') {\n            payload['failure'] = failure;\n        }\n        if (typeof scopes !== 'undefined') {\n            payload['scopes'] = scopes;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        if (typeof window !== 'undefined' && (window === null || window === void 0 ? void 0 : window.location)) {\n            window.location.href = uri.toString();\n            return;\n        }\n        else {\n            return uri.toString();\n        }\n    }\n    createPhoneToken(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                phone: rest[0]\n            };\n        }\n        const userId = params.userId;\n        const phone = params.phone;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof phone === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"phone\"');\n        }\n        const apiPath = '/account/tokens/phone';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof phone !== 'undefined') {\n            payload['phone'] = phone;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    createVerification(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                url: paramsOrFirst\n            };\n        }\n        const url = params.url;\n        if (typeof url === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n        const apiPath = '/account/verification';\n        const payload = {};\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    updateVerification(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                secret: rest[0]\n            };\n        }\n        const userId = params.userId;\n        const secret = params.secret;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n        const apiPath = '/account/verification';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    /**\n     * Use this endpoint to send a verification SMS to the currently logged in user. This endpoint is meant for use after updating a user's phone number using the [accountUpdatePhone](https://appwrite.io/docs/references/cloud/client-web/account#updatePhone) endpoint. Learn more about how to [complete the verification process](https://appwrite.io/docs/references/cloud/client-web/account#updatePhoneVerification). The verification code sent to the user's phone number is valid for 15 minutes.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Token>}\n     */\n    createPhoneVerification() {\n        const apiPath = '/account/verification/phone';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    updatePhoneVerification(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                secret: rest[0]\n            };\n        }\n        const userId = params.userId;\n        const secret = params.secret;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n        const apiPath = '/account/verification/phone';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n}\n\nclass Avatars {\n    constructor(client) {\n        this.client = client;\n    }\n    getBrowser(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'code' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                code: paramsOrFirst,\n                width: rest[0],\n                height: rest[1],\n                quality: rest[2]\n            };\n        }\n        const code = params.code;\n        const width = params.width;\n        const height = params.height;\n        const quality = params.quality;\n        if (typeof code === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"code\"');\n        }\n        const apiPath = '/avatars/browsers/{code}'.replace('{code}', code);\n        const payload = {};\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n        if (typeof quality !== 'undefined') {\n            payload['quality'] = quality;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n    getCreditCard(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'code' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                code: paramsOrFirst,\n                width: rest[0],\n                height: rest[1],\n                quality: rest[2]\n            };\n        }\n        const code = params.code;\n        const width = params.width;\n        const height = params.height;\n        const quality = params.quality;\n        if (typeof code === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"code\"');\n        }\n        const apiPath = '/avatars/credit-cards/{code}'.replace('{code}', code);\n        const payload = {};\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n        if (typeof quality !== 'undefined') {\n            payload['quality'] = quality;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n    getFavicon(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                url: paramsOrFirst\n            };\n        }\n        const url = params.url;\n        if (typeof url === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n        const apiPath = '/avatars/favicon';\n        const payload = {};\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n    getFlag(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'code' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                code: paramsOrFirst,\n                width: rest[0],\n                height: rest[1],\n                quality: rest[2]\n            };\n        }\n        const code = params.code;\n        const width = params.width;\n        const height = params.height;\n        const quality = params.quality;\n        if (typeof code === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"code\"');\n        }\n        const apiPath = '/avatars/flags/{code}'.replace('{code}', code);\n        const payload = {};\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n        if (typeof quality !== 'undefined') {\n            payload['quality'] = quality;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n    getImage(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                url: paramsOrFirst,\n                width: rest[0],\n                height: rest[1]\n            };\n        }\n        const url = params.url;\n        const width = params.width;\n        const height = params.height;\n        if (typeof url === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n        const apiPath = '/avatars/image';\n        const payload = {};\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n    getInitials(paramsOrFirst, ...rest) {\n        let params;\n        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                name: paramsOrFirst,\n                width: rest[0],\n                height: rest[1],\n                background: rest[2]\n            };\n        }\n        const name = params.name;\n        const width = params.width;\n        const height = params.height;\n        const background = params.background;\n        const apiPath = '/avatars/initials';\n        const payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n        if (typeof background !== 'undefined') {\n            payload['background'] = background;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n    getQR(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                text: paramsOrFirst,\n                size: rest[0],\n                margin: rest[1],\n                download: rest[2]\n            };\n        }\n        const text = params.text;\n        const size = params.size;\n        const margin = params.margin;\n        const download = params.download;\n        if (typeof text === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"text\"');\n        }\n        const apiPath = '/avatars/qr';\n        const payload = {};\n        if (typeof text !== 'undefined') {\n            payload['text'] = text;\n        }\n        if (typeof size !== 'undefined') {\n            payload['size'] = size;\n        }\n        if (typeof margin !== 'undefined') {\n            payload['margin'] = margin;\n        }\n        if (typeof download !== 'undefined') {\n            payload['download'] = download;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n}\n\nclass Databases {\n    constructor(client) {\n        this.client = client;\n    }\n    listDocuments(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                collectionId: rest[0],\n                queries: rest[1]\n            };\n        }\n        const databaseId = params.databaseId;\n        const collectionId = params.collectionId;\n        const queries = params.queries;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    createDocument(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                collectionId: rest[0],\n                documentId: rest[1],\n                data: rest[2],\n                permissions: rest[3]\n            };\n        }\n        const databaseId = params.databaseId;\n        const collectionId = params.collectionId;\n        const documentId = params.documentId;\n        const data = params.data;\n        const permissions = params.permissions;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n        if (typeof data === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"data\"');\n        }\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        const payload = {};\n        if (typeof documentId !== 'undefined') {\n            payload['documentId'] = documentId;\n        }\n        if (typeof data !== 'undefined') {\n            payload['data'] = data;\n        }\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    getDocument(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                collectionId: rest[0],\n                documentId: rest[1],\n                queries: rest[2]\n            };\n        }\n        const databaseId = params.databaseId;\n        const collectionId = params.collectionId;\n        const documentId = params.documentId;\n        const queries = params.queries;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    upsertDocument(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                collectionId: rest[0],\n                documentId: rest[1],\n                data: rest[2],\n                permissions: rest[3]\n            };\n        }\n        const databaseId = params.databaseId;\n        const collectionId = params.collectionId;\n        const documentId = params.documentId;\n        const data = params.data;\n        const permissions = params.permissions;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n        if (typeof data === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"data\"');\n        }\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);\n        const payload = {};\n        if (typeof data !== 'undefined') {\n            payload['data'] = data;\n        }\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    updateDocument(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                collectionId: rest[0],\n                documentId: rest[1],\n                data: rest[2],\n                permissions: rest[3]\n            };\n        }\n        const databaseId = params.databaseId;\n        const collectionId = params.collectionId;\n        const documentId = params.documentId;\n        const data = params.data;\n        const permissions = params.permissions;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);\n        const payload = {};\n        if (typeof data !== 'undefined') {\n            payload['data'] = data;\n        }\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    deleteDocument(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                collectionId: rest[0],\n                documentId: rest[1]\n            };\n        }\n        const databaseId = params.databaseId;\n        const collectionId = params.collectionId;\n        const documentId = params.documentId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    decrementDocumentAttribute(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                collectionId: rest[0],\n                documentId: rest[1],\n                attribute: rest[2],\n                value: rest[3],\n                min: rest[4]\n            };\n        }\n        const databaseId = params.databaseId;\n        const collectionId = params.collectionId;\n        const documentId = params.documentId;\n        const attribute = params.attribute;\n        const value = params.value;\n        const min = params.min;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n        if (typeof attribute === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"attribute\"');\n        }\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}/{attribute}/decrement'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId).replace('{attribute}', attribute);\n        const payload = {};\n        if (typeof value !== 'undefined') {\n            payload['value'] = value;\n        }\n        if (typeof min !== 'undefined') {\n            payload['min'] = min;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    incrementDocumentAttribute(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                collectionId: rest[0],\n                documentId: rest[1],\n                attribute: rest[2],\n                value: rest[3],\n                max: rest[4]\n            };\n        }\n        const databaseId = params.databaseId;\n        const collectionId = params.collectionId;\n        const documentId = params.documentId;\n        const attribute = params.attribute;\n        const value = params.value;\n        const max = params.max;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n        if (typeof attribute === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"attribute\"');\n        }\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}/{attribute}/increment'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId).replace('{attribute}', attribute);\n        const payload = {};\n        if (typeof value !== 'undefined') {\n            payload['value'] = value;\n        }\n        if (typeof max !== 'undefined') {\n            payload['max'] = max;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n}\n\nclass Functions {\n    constructor(client) {\n        this.client = client;\n    }\n    listExecutions(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                functionId: paramsOrFirst,\n                queries: rest[0]\n            };\n        }\n        const functionId = params.functionId;\n        const queries = params.queries;\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n        const apiPath = '/functions/{functionId}/executions'.replace('{functionId}', functionId);\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    createExecution(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                functionId: paramsOrFirst,\n                body: rest[0],\n                async: rest[1],\n                xpath: rest[2],\n                method: rest[3],\n                headers: rest[4],\n                scheduledAt: rest[5]\n            };\n        }\n        const functionId = params.functionId;\n        const body = params.body;\n        const async = params.async;\n        const xpath = params.xpath;\n        const method = params.method;\n        const headers = params.headers;\n        const scheduledAt = params.scheduledAt;\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n        const apiPath = '/functions/{functionId}/executions'.replace('{functionId}', functionId);\n        const payload = {};\n        if (typeof body !== 'undefined') {\n            payload['body'] = body;\n        }\n        if (typeof async !== 'undefined') {\n            payload['async'] = async;\n        }\n        if (typeof xpath !== 'undefined') {\n            payload['path'] = xpath;\n        }\n        if (typeof method !== 'undefined') {\n            payload['method'] = method;\n        }\n        if (typeof headers !== 'undefined') {\n            payload['headers'] = headers;\n        }\n        if (typeof scheduledAt !== 'undefined') {\n            payload['scheduledAt'] = scheduledAt;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    getExecution(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                functionId: paramsOrFirst,\n                executionId: rest[0]\n            };\n        }\n        const functionId = params.functionId;\n        const executionId = params.executionId;\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n        if (typeof executionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"executionId\"');\n        }\n        const apiPath = '/functions/{functionId}/executions/{executionId}'.replace('{functionId}', functionId).replace('{executionId}', executionId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n}\n\nclass Graphql {\n    constructor(client) {\n        this.client = client;\n    }\n    query(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'query' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                query: paramsOrFirst\n            };\n        }\n        const query = params.query;\n        if (typeof query === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"query\"');\n        }\n        const apiPath = '/graphql';\n        const payload = {};\n        if (typeof query !== 'undefined') {\n            payload['query'] = query;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'x-sdk-graphql': 'true',\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    mutation(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'query' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                query: paramsOrFirst\n            };\n        }\n        const query = params.query;\n        if (typeof query === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"query\"');\n        }\n        const apiPath = '/graphql/mutation';\n        const payload = {};\n        if (typeof query !== 'undefined') {\n            payload['query'] = query;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'x-sdk-graphql': 'true',\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n}\n\nclass Locale {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Get the current user location based on IP. Returns an object with user country code, country name, continent name, continent code, ip address and suggested currency. You can use the locale header to get the data in a supported language.\n     *\n     * ([IP Geolocation by DB-IP](https://db-ip.com))\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Locale>}\n     */\n    get() {\n        const apiPath = '/locale';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * List of all locale codes in [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes).\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.LocaleCodeList>}\n     */\n    listCodes() {\n        const apiPath = '/locale/codes';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * List of all continents. You can use the locale header to get the data in a supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.ContinentList>}\n     */\n    listContinents() {\n        const apiPath = '/locale/continents';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * List of all countries. You can use the locale header to get the data in a supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.CountryList>}\n     */\n    listCountries() {\n        const apiPath = '/locale/countries';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * List of all countries that are currently members of the EU. You can use the locale header to get the data in a supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.CountryList>}\n     */\n    listCountriesEU() {\n        const apiPath = '/locale/countries/eu';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * List of all countries phone codes. You can use the locale header to get the data in a supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.PhoneList>}\n     */\n    listCountriesPhones() {\n        const apiPath = '/locale/countries/phones';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * List of all currencies, including currency symbol, name, plural, and decimal digits for all major and minor currencies. You can use the locale header to get the data in a supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.CurrencyList>}\n     */\n    listCurrencies() {\n        const apiPath = '/locale/currencies';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * List of all languages classified by ISO 639-1 including 2-letter code, name in English, and name in the respective language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.LanguageList>}\n     */\n    listLanguages() {\n        const apiPath = '/locale/languages';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n}\n\nclass Messaging {\n    constructor(client) {\n        this.client = client;\n    }\n    createSubscriber(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                topicId: paramsOrFirst,\n                subscriberId: rest[0],\n                targetId: rest[1]\n            };\n        }\n        const topicId = params.topicId;\n        const subscriberId = params.subscriberId;\n        const targetId = params.targetId;\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n        if (typeof subscriberId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"subscriberId\"');\n        }\n        if (typeof targetId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"targetId\"');\n        }\n        const apiPath = '/messaging/topics/{topicId}/subscribers'.replace('{topicId}', topicId);\n        const payload = {};\n        if (typeof subscriberId !== 'undefined') {\n            payload['subscriberId'] = subscriberId;\n        }\n        if (typeof targetId !== 'undefined') {\n            payload['targetId'] = targetId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    deleteSubscriber(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                topicId: paramsOrFirst,\n                subscriberId: rest[0]\n            };\n        }\n        const topicId = params.topicId;\n        const subscriberId = params.subscriberId;\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n        if (typeof subscriberId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"subscriberId\"');\n        }\n        const apiPath = '/messaging/topics/{topicId}/subscribers/{subscriberId}'.replace('{topicId}', topicId).replace('{subscriberId}', subscriberId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n}\n\nclass Storage {\n    constructor(client) {\n        this.client = client;\n    }\n    listFiles(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                bucketId: paramsOrFirst,\n                queries: rest[0],\n                search: rest[1]\n            };\n        }\n        const bucketId = params.bucketId;\n        const queries = params.queries;\n        const search = params.search;\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        const apiPath = '/storage/buckets/{bucketId}/files'.replace('{bucketId}', bucketId);\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    createFile(paramsOrFirst, ...rest) {\n        let params;\n        let onProgress;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n            onProgress = paramsOrFirst === null || paramsOrFirst === void 0 ? void 0 : paramsOrFirst.onProgress;\n        }\n        else {\n            params = {\n                bucketId: paramsOrFirst,\n                fileId: rest[0],\n                file: rest[1],\n                permissions: rest[2]\n            };\n            onProgress = rest[3];\n        }\n        const bucketId = params.bucketId;\n        const fileId = params.fileId;\n        const file = params.file;\n        const permissions = params.permissions;\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        if (typeof file === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"file\"');\n        }\n        const apiPath = '/storage/buckets/{bucketId}/files'.replace('{bucketId}', bucketId);\n        const payload = {};\n        if (typeof fileId !== 'undefined') {\n            payload['fileId'] = fileId;\n        }\n        if (typeof file !== 'undefined') {\n            payload['file'] = file;\n        }\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'multipart/form-data',\n        };\n        return this.client.chunkedUpload('post', uri, apiHeaders, payload, onProgress);\n    }\n    getFile(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                bucketId: paramsOrFirst,\n                fileId: rest[0]\n            };\n        }\n        const bucketId = params.bucketId;\n        const fileId = params.fileId;\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    updateFile(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                bucketId: paramsOrFirst,\n                fileId: rest[0],\n                name: rest[1],\n                permissions: rest[2]\n            };\n        }\n        const bucketId = params.bucketId;\n        const fileId = params.fileId;\n        const name = params.name;\n        const permissions = params.permissions;\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        const payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    deleteFile(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                bucketId: paramsOrFirst,\n                fileId: rest[0]\n            };\n        }\n        const bucketId = params.bucketId;\n        const fileId = params.fileId;\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    getFileDownload(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                bucketId: paramsOrFirst,\n                fileId: rest[0],\n                token: rest[1]\n            };\n        }\n        const bucketId = params.bucketId;\n        const fileId = params.fileId;\n        const token = params.token;\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}/download'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        const payload = {};\n        if (typeof token !== 'undefined') {\n            payload['token'] = token;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n    getFilePreview(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                bucketId: paramsOrFirst,\n                fileId: rest[0],\n                width: rest[1],\n                height: rest[2],\n                gravity: rest[3],\n                quality: rest[4],\n                borderWidth: rest[5],\n                borderColor: rest[6],\n                borderRadius: rest[7],\n                opacity: rest[8],\n                rotation: rest[9],\n                background: rest[10],\n                output: rest[11],\n                token: rest[12]\n            };\n        }\n        const bucketId = params.bucketId;\n        const fileId = params.fileId;\n        const width = params.width;\n        const height = params.height;\n        const gravity = params.gravity;\n        const quality = params.quality;\n        const borderWidth = params.borderWidth;\n        const borderColor = params.borderColor;\n        const borderRadius = params.borderRadius;\n        const opacity = params.opacity;\n        const rotation = params.rotation;\n        const background = params.background;\n        const output = params.output;\n        const token = params.token;\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}/preview'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        const payload = {};\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n        if (typeof gravity !== 'undefined') {\n            payload['gravity'] = gravity;\n        }\n        if (typeof quality !== 'undefined') {\n            payload['quality'] = quality;\n        }\n        if (typeof borderWidth !== 'undefined') {\n            payload['borderWidth'] = borderWidth;\n        }\n        if (typeof borderColor !== 'undefined') {\n            payload['borderColor'] = borderColor;\n        }\n        if (typeof borderRadius !== 'undefined') {\n            payload['borderRadius'] = borderRadius;\n        }\n        if (typeof opacity !== 'undefined') {\n            payload['opacity'] = opacity;\n        }\n        if (typeof rotation !== 'undefined') {\n            payload['rotation'] = rotation;\n        }\n        if (typeof background !== 'undefined') {\n            payload['background'] = background;\n        }\n        if (typeof output !== 'undefined') {\n            payload['output'] = output;\n        }\n        if (typeof token !== 'undefined') {\n            payload['token'] = token;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n    getFileView(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                bucketId: paramsOrFirst,\n                fileId: rest[0],\n                token: rest[1]\n            };\n        }\n        const bucketId = params.bucketId;\n        const fileId = params.fileId;\n        const token = params.token;\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}/view'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        const payload = {};\n        if (typeof token !== 'undefined') {\n            payload['token'] = token;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n}\n\nclass TablesDB {\n    constructor(client) {\n        this.client = client;\n    }\n    listRows(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                tableId: rest[0],\n                queries: rest[1]\n            };\n        }\n        const databaseId = params.databaseId;\n        const tableId = params.tableId;\n        const queries = params.queries;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof tableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"tableId\"');\n        }\n        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    createRow(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                tableId: rest[0],\n                rowId: rest[1],\n                data: rest[2],\n                permissions: rest[3]\n            };\n        }\n        const databaseId = params.databaseId;\n        const tableId = params.tableId;\n        const rowId = params.rowId;\n        const data = params.data;\n        const permissions = params.permissions;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof tableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"tableId\"');\n        }\n        if (typeof rowId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"rowId\"');\n        }\n        if (typeof data === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"data\"');\n        }\n        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);\n        const payload = {};\n        if (typeof rowId !== 'undefined') {\n            payload['rowId'] = rowId;\n        }\n        if (typeof data !== 'undefined') {\n            payload['data'] = data;\n        }\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    getRow(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                tableId: rest[0],\n                rowId: rest[1],\n                queries: rest[2]\n            };\n        }\n        const databaseId = params.databaseId;\n        const tableId = params.tableId;\n        const rowId = params.rowId;\n        const queries = params.queries;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof tableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"tableId\"');\n        }\n        if (typeof rowId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"rowId\"');\n        }\n        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId);\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    upsertRow(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                tableId: rest[0],\n                rowId: rest[1],\n                data: rest[2],\n                permissions: rest[3]\n            };\n        }\n        const databaseId = params.databaseId;\n        const tableId = params.tableId;\n        const rowId = params.rowId;\n        const data = params.data;\n        const permissions = params.permissions;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof tableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"tableId\"');\n        }\n        if (typeof rowId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"rowId\"');\n        }\n        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId);\n        const payload = {};\n        if (typeof data !== 'undefined') {\n            payload['data'] = data;\n        }\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    updateRow(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                tableId: rest[0],\n                rowId: rest[1],\n                data: rest[2],\n                permissions: rest[3]\n            };\n        }\n        const databaseId = params.databaseId;\n        const tableId = params.tableId;\n        const rowId = params.rowId;\n        const data = params.data;\n        const permissions = params.permissions;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof tableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"tableId\"');\n        }\n        if (typeof rowId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"rowId\"');\n        }\n        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId);\n        const payload = {};\n        if (typeof data !== 'undefined') {\n            payload['data'] = data;\n        }\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    deleteRow(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                tableId: rest[0],\n                rowId: rest[1]\n            };\n        }\n        const databaseId = params.databaseId;\n        const tableId = params.tableId;\n        const rowId = params.rowId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof tableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"tableId\"');\n        }\n        if (typeof rowId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"rowId\"');\n        }\n        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    decrementRowColumn(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                tableId: rest[0],\n                rowId: rest[1],\n                column: rest[2],\n                value: rest[3],\n                min: rest[4]\n            };\n        }\n        const databaseId = params.databaseId;\n        const tableId = params.tableId;\n        const rowId = params.rowId;\n        const column = params.column;\n        const value = params.value;\n        const min = params.min;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof tableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"tableId\"');\n        }\n        if (typeof rowId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"rowId\"');\n        }\n        if (typeof column === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"column\"');\n        }\n        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}/{column}/decrement'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId).replace('{column}', column);\n        const payload = {};\n        if (typeof value !== 'undefined') {\n            payload['value'] = value;\n        }\n        if (typeof min !== 'undefined') {\n            payload['min'] = min;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    incrementRowColumn(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                tableId: rest[0],\n                rowId: rest[1],\n                column: rest[2],\n                value: rest[3],\n                max: rest[4]\n            };\n        }\n        const databaseId = params.databaseId;\n        const tableId = params.tableId;\n        const rowId = params.rowId;\n        const column = params.column;\n        const value = params.value;\n        const max = params.max;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof tableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"tableId\"');\n        }\n        if (typeof rowId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"rowId\"');\n        }\n        if (typeof column === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"column\"');\n        }\n        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}/{column}/increment'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId).replace('{column}', column);\n        const payload = {};\n        if (typeof value !== 'undefined') {\n            payload['value'] = value;\n        }\n        if (typeof max !== 'undefined') {\n            payload['max'] = max;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n}\n\nclass Teams {\n    constructor(client) {\n        this.client = client;\n    }\n    list(paramsOrFirst, ...rest) {\n        let params;\n        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                queries: paramsOrFirst,\n                search: rest[0]\n            };\n        }\n        const queries = params.queries;\n        const search = params.search;\n        const apiPath = '/teams';\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    create(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst,\n                name: rest[0],\n                roles: rest[1]\n            };\n        }\n        const teamId = params.teamId;\n        const name = params.name;\n        const roles = params.roles;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n        const apiPath = '/teams';\n        const payload = {};\n        if (typeof teamId !== 'undefined') {\n            payload['teamId'] = teamId;\n        }\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof roles !== 'undefined') {\n            payload['roles'] = roles;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    get(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst\n            };\n        }\n        const teamId = params.teamId;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        const apiPath = '/teams/{teamId}'.replace('{teamId}', teamId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    updateName(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst,\n                name: rest[0]\n            };\n        }\n        const teamId = params.teamId;\n        const name = params.name;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n        const apiPath = '/teams/{teamId}'.replace('{teamId}', teamId);\n        const payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    delete(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst\n            };\n        }\n        const teamId = params.teamId;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        const apiPath = '/teams/{teamId}'.replace('{teamId}', teamId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    listMemberships(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst,\n                queries: rest[0],\n                search: rest[1]\n            };\n        }\n        const teamId = params.teamId;\n        const queries = params.queries;\n        const search = params.search;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        const apiPath = '/teams/{teamId}/memberships'.replace('{teamId}', teamId);\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    createMembership(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst,\n                roles: rest[0],\n                email: rest[1],\n                userId: rest[2],\n                phone: rest[3],\n                url: rest[4],\n                name: rest[5]\n            };\n        }\n        const teamId = params.teamId;\n        const roles = params.roles;\n        const email = params.email;\n        const userId = params.userId;\n        const phone = params.phone;\n        const url = params.url;\n        const name = params.name;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof roles === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"roles\"');\n        }\n        const apiPath = '/teams/{teamId}/memberships'.replace('{teamId}', teamId);\n        const payload = {};\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof phone !== 'undefined') {\n            payload['phone'] = phone;\n        }\n        if (typeof roles !== 'undefined') {\n            payload['roles'] = roles;\n        }\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    getMembership(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst,\n                membershipId: rest[0]\n            };\n        }\n        const teamId = params.teamId;\n        const membershipId = params.membershipId;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof membershipId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"membershipId\"');\n        }\n        const apiPath = '/teams/{teamId}/memberships/{membershipId}'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    updateMembership(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst,\n                membershipId: rest[0],\n                roles: rest[1]\n            };\n        }\n        const teamId = params.teamId;\n        const membershipId = params.membershipId;\n        const roles = params.roles;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof membershipId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"membershipId\"');\n        }\n        if (typeof roles === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"roles\"');\n        }\n        const apiPath = '/teams/{teamId}/memberships/{membershipId}'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);\n        const payload = {};\n        if (typeof roles !== 'undefined') {\n            payload['roles'] = roles;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    deleteMembership(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst,\n                membershipId: rest[0]\n            };\n        }\n        const teamId = params.teamId;\n        const membershipId = params.membershipId;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof membershipId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"membershipId\"');\n        }\n        const apiPath = '/teams/{teamId}/memberships/{membershipId}'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    updateMembershipStatus(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst,\n                membershipId: rest[0],\n                userId: rest[1],\n                secret: rest[2]\n            };\n        }\n        const teamId = params.teamId;\n        const membershipId = params.membershipId;\n        const userId = params.userId;\n        const secret = params.secret;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof membershipId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"membershipId\"');\n        }\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n        const apiPath = '/teams/{teamId}/memberships/{membershipId}/status'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    getPrefs(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst\n            };\n        }\n        const teamId = params.teamId;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        const apiPath = '/teams/{teamId}/prefs'.replace('{teamId}', teamId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    updatePrefs(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst,\n                prefs: rest[0]\n            };\n        }\n        const teamId = params.teamId;\n        const prefs = params.prefs;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof prefs === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"prefs\"');\n        }\n        const apiPath = '/teams/{teamId}/prefs'.replace('{teamId}', teamId);\n        const payload = {};\n        if (typeof prefs !== 'undefined') {\n            payload['prefs'] = prefs;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n}\n\n/**\n * Helper class to generate permission strings for resources.\n */\nclass Permission {\n}\n/**\n * Generate read permission string for the provided role.\n *\n * @param {string} role\n * @returns {string}\n */\nPermission.read = (role) => {\n    return `read(\"${role}\")`;\n};\n/**\n * Generate write permission string for the provided role.\n *\n * This is an alias of update, delete, and possibly create.\n * Don't use write in combination with update, delete, or create.\n *\n * @param {string} role\n * @returns {string}\n */\nPermission.write = (role) => {\n    return `write(\"${role}\")`;\n};\n/**\n * Generate create permission string for the provided role.\n *\n * @param {string} role\n * @returns {string}\n */\nPermission.create = (role) => {\n    return `create(\"${role}\")`;\n};\n/**\n * Generate update permission string for the provided role.\n *\n * @param {string} role\n * @returns {string}\n */\nPermission.update = (role) => {\n    return `update(\"${role}\")`;\n};\n/**\n * Generate delete permission string for the provided role.\n *\n * @param {string} role\n * @returns {string}\n */\nPermission.delete = (role) => {\n    return `delete(\"${role}\")`;\n};\n\n/**\n * Helper class to generate role strings for `Permission`.\n */\nclass Role {\n    /**\n     * Grants access to anyone.\n     *\n     * This includes authenticated and unauthenticated users.\n     *\n     * @returns {string}\n     */\n    static any() {\n        return 'any';\n    }\n    /**\n     * Grants access to a specific user by user ID.\n     *\n     * You can optionally pass verified or unverified for\n     * `status` to target specific types of users.\n     *\n     * @param {string} id\n     * @param {string} status\n     * @returns {string}\n     */\n    static user(id, status = '') {\n        if (status === '') {\n            return `user:${id}`;\n        }\n        return `user:${id}/${status}`;\n    }\n    /**\n     * Grants access to any authenticated or anonymous user.\n     *\n     * You can optionally pass verified or unverified for\n     * `status` to target specific types of users.\n     *\n     * @param {string} status\n     * @returns {string}\n     */\n    static users(status = '') {\n        if (status === '') {\n            return 'users';\n        }\n        return `users/${status}`;\n    }\n    /**\n     * Grants access to any guest user without a session.\n     *\n     * Authenticated users don't have access to this role.\n     *\n     * @returns {string}\n     */\n    static guests() {\n        return 'guests';\n    }\n    /**\n     * Grants access to a team by team ID.\n     *\n     * You can optionally pass a role for `role` to target\n     * team members with the specified role.\n     *\n     * @param {string} id\n     * @param {string} role\n     * @returns {string}\n     */\n    static team(id, role = '') {\n        if (role === '') {\n            return `team:${id}`;\n        }\n        return `team:${id}/${role}`;\n    }\n    /**\n     * Grants access to a specific member of a team.\n     *\n     * When the member is removed from the team, they will\n     * no longer have access.\n     *\n     * @param {string} id\n     * @returns {string}\n     */\n    static member(id) {\n        return `member:${id}`;\n    }\n    /**\n     * Grants access to a user with the specified label.\n     *\n     * @param {string} name\n     * @returns  {string}\n     */\n    static label(name) {\n        return `label:${name}`;\n    }\n}\n\nvar _a, _ID_hexTimestamp;\n/**\n * Helper class to generate ID strings for resources.\n */\nclass ID {\n    /**\n     * Uses the provided ID as the ID for the resource.\n     *\n     * @param {string} id\n     * @returns {string}\n     */\n    static custom(id) {\n        return id;\n    }\n    /**\n     * Have Appwrite generate a unique ID for you.\n     *\n     * @param {number} padding. Default is 7.\n     * @returns {string}\n     */\n    static unique(padding = 7) {\n        // Generate a unique ID with padding to have a longer ID\n        const baseId = __classPrivateFieldGet(ID, _a, \"m\", _ID_hexTimestamp).call(ID);\n        let randomPadding = '';\n        for (let i = 0; i < padding; i++) {\n            const randomHexDigit = Math.floor(Math.random() * 16).toString(16);\n            randomPadding += randomHexDigit;\n        }\n        return baseId + randomPadding;\n    }\n}\n_a = ID, _ID_hexTimestamp = function _ID_hexTimestamp() {\n    const now = new Date();\n    const sec = Math.floor(now.getTime() / 1000);\n    const msec = now.getMilliseconds();\n    // Convert to hexadecimal\n    const hexTimestamp = sec.toString(16) + msec.toString(16).padStart(5, '0');\n    return hexTimestamp;\n};\n\nvar AuthenticatorType;\n(function (AuthenticatorType) {\n    AuthenticatorType[\"Totp\"] = \"totp\";\n})(AuthenticatorType || (AuthenticatorType = {}));\n\nvar AuthenticationFactor;\n(function (AuthenticationFactor) {\n    AuthenticationFactor[\"Email\"] = \"email\";\n    AuthenticationFactor[\"Phone\"] = \"phone\";\n    AuthenticationFactor[\"Totp\"] = \"totp\";\n    AuthenticationFactor[\"Recoverycode\"] = \"recoverycode\";\n})(AuthenticationFactor || (AuthenticationFactor = {}));\n\nvar OAuthProvider;\n(function (OAuthProvider) {\n    OAuthProvider[\"Amazon\"] = \"amazon\";\n    OAuthProvider[\"Apple\"] = \"apple\";\n    OAuthProvider[\"Auth0\"] = \"auth0\";\n    OAuthProvider[\"Authentik\"] = \"authentik\";\n    OAuthProvider[\"Autodesk\"] = \"autodesk\";\n    OAuthProvider[\"Bitbucket\"] = \"bitbucket\";\n    OAuthProvider[\"Bitly\"] = \"bitly\";\n    OAuthProvider[\"Box\"] = \"box\";\n    OAuthProvider[\"Dailymotion\"] = \"dailymotion\";\n    OAuthProvider[\"Discord\"] = \"discord\";\n    OAuthProvider[\"Disqus\"] = \"disqus\";\n    OAuthProvider[\"Dropbox\"] = \"dropbox\";\n    OAuthProvider[\"Etsy\"] = \"etsy\";\n    OAuthProvider[\"Facebook\"] = \"facebook\";\n    OAuthProvider[\"Figma\"] = \"figma\";\n    OAuthProvider[\"Github\"] = \"github\";\n    OAuthProvider[\"Gitlab\"] = \"gitlab\";\n    OAuthProvider[\"Google\"] = \"google\";\n    OAuthProvider[\"Linkedin\"] = \"linkedin\";\n    OAuthProvider[\"Microsoft\"] = \"microsoft\";\n    OAuthProvider[\"Notion\"] = \"notion\";\n    OAuthProvider[\"Oidc\"] = \"oidc\";\n    OAuthProvider[\"Okta\"] = \"okta\";\n    OAuthProvider[\"Paypal\"] = \"paypal\";\n    OAuthProvider[\"PaypalSandbox\"] = \"paypalSandbox\";\n    OAuthProvider[\"Podio\"] = \"podio\";\n    OAuthProvider[\"Salesforce\"] = \"salesforce\";\n    OAuthProvider[\"Slack\"] = \"slack\";\n    OAuthProvider[\"Spotify\"] = \"spotify\";\n    OAuthProvider[\"Stripe\"] = \"stripe\";\n    OAuthProvider[\"Tradeshift\"] = \"tradeshift\";\n    OAuthProvider[\"TradeshiftBox\"] = \"tradeshiftBox\";\n    OAuthProvider[\"Twitch\"] = \"twitch\";\n    OAuthProvider[\"Wordpress\"] = \"wordpress\";\n    OAuthProvider[\"Yahoo\"] = \"yahoo\";\n    OAuthProvider[\"Yammer\"] = \"yammer\";\n    OAuthProvider[\"Yandex\"] = \"yandex\";\n    OAuthProvider[\"Zoho\"] = \"zoho\";\n    OAuthProvider[\"Zoom\"] = \"zoom\";\n    OAuthProvider[\"Mock\"] = \"mock\";\n})(OAuthProvider || (OAuthProvider = {}));\n\nvar Browser;\n(function (Browser) {\n    Browser[\"AvantBrowser\"] = \"aa\";\n    Browser[\"AndroidWebViewBeta\"] = \"an\";\n    Browser[\"GoogleChrome\"] = \"ch\";\n    Browser[\"GoogleChromeIOS\"] = \"ci\";\n    Browser[\"GoogleChromeMobile\"] = \"cm\";\n    Browser[\"Chromium\"] = \"cr\";\n    Browser[\"MozillaFirefox\"] = \"ff\";\n    Browser[\"Safari\"] = \"sf\";\n    Browser[\"MobileSafari\"] = \"mf\";\n    Browser[\"MicrosoftEdge\"] = \"ps\";\n    Browser[\"MicrosoftEdgeIOS\"] = \"oi\";\n    Browser[\"OperaMini\"] = \"om\";\n    Browser[\"Opera\"] = \"op\";\n    Browser[\"OperaNext\"] = \"on\";\n})(Browser || (Browser = {}));\n\nvar CreditCard;\n(function (CreditCard) {\n    CreditCard[\"AmericanExpress\"] = \"amex\";\n    CreditCard[\"Argencard\"] = \"argencard\";\n    CreditCard[\"Cabal\"] = \"cabal\";\n    CreditCard[\"Cencosud\"] = \"cencosud\";\n    CreditCard[\"DinersClub\"] = \"diners\";\n    CreditCard[\"Discover\"] = \"discover\";\n    CreditCard[\"Elo\"] = \"elo\";\n    CreditCard[\"Hipercard\"] = \"hipercard\";\n    CreditCard[\"JCB\"] = \"jcb\";\n    CreditCard[\"Mastercard\"] = \"mastercard\";\n    CreditCard[\"Naranja\"] = \"naranja\";\n    CreditCard[\"TarjetaShopping\"] = \"targeta-shopping\";\n    CreditCard[\"UnionPay\"] = \"unionpay\";\n    CreditCard[\"Visa\"] = \"visa\";\n    CreditCard[\"MIR\"] = \"mir\";\n    CreditCard[\"Maestro\"] = \"maestro\";\n    CreditCard[\"Rupay\"] = \"rupay\";\n})(CreditCard || (CreditCard = {}));\n\nvar Flag;\n(function (Flag) {\n    Flag[\"Afghanistan\"] = \"af\";\n    Flag[\"Angola\"] = \"ao\";\n    Flag[\"Albania\"] = \"al\";\n    Flag[\"Andorra\"] = \"ad\";\n    Flag[\"UnitedArabEmirates\"] = \"ae\";\n    Flag[\"Argentina\"] = \"ar\";\n    Flag[\"Armenia\"] = \"am\";\n    Flag[\"AntiguaAndBarbuda\"] = \"ag\";\n    Flag[\"Australia\"] = \"au\";\n    Flag[\"Austria\"] = \"at\";\n    Flag[\"Azerbaijan\"] = \"az\";\n    Flag[\"Burundi\"] = \"bi\";\n    Flag[\"Belgium\"] = \"be\";\n    Flag[\"Benin\"] = \"bj\";\n    Flag[\"BurkinaFaso\"] = \"bf\";\n    Flag[\"Bangladesh\"] = \"bd\";\n    Flag[\"Bulgaria\"] = \"bg\";\n    Flag[\"Bahrain\"] = \"bh\";\n    Flag[\"Bahamas\"] = \"bs\";\n    Flag[\"BosniaAndHerzegovina\"] = \"ba\";\n    Flag[\"Belarus\"] = \"by\";\n    Flag[\"Belize\"] = \"bz\";\n    Flag[\"Bolivia\"] = \"bo\";\n    Flag[\"Brazil\"] = \"br\";\n    Flag[\"Barbados\"] = \"bb\";\n    Flag[\"BruneiDarussalam\"] = \"bn\";\n    Flag[\"Bhutan\"] = \"bt\";\n    Flag[\"Botswana\"] = \"bw\";\n    Flag[\"CentralAfricanRepublic\"] = \"cf\";\n    Flag[\"Canada\"] = \"ca\";\n    Flag[\"Switzerland\"] = \"ch\";\n    Flag[\"Chile\"] = \"cl\";\n    Flag[\"China\"] = \"cn\";\n    Flag[\"CoteDIvoire\"] = \"ci\";\n    Flag[\"Cameroon\"] = \"cm\";\n    Flag[\"DemocraticRepublicOfTheCongo\"] = \"cd\";\n    Flag[\"RepublicOfTheCongo\"] = \"cg\";\n    Flag[\"Colombia\"] = \"co\";\n    Flag[\"Comoros\"] = \"km\";\n    Flag[\"CapeVerde\"] = \"cv\";\n    Flag[\"CostaRica\"] = \"cr\";\n    Flag[\"Cuba\"] = \"cu\";\n    Flag[\"Cyprus\"] = \"cy\";\n    Flag[\"CzechRepublic\"] = \"cz\";\n    Flag[\"Germany\"] = \"de\";\n    Flag[\"Djibouti\"] = \"dj\";\n    Flag[\"Dominica\"] = \"dm\";\n    Flag[\"Denmark\"] = \"dk\";\n    Flag[\"DominicanRepublic\"] = \"do\";\n    Flag[\"Algeria\"] = \"dz\";\n    Flag[\"Ecuador\"] = \"ec\";\n    Flag[\"Egypt\"] = \"eg\";\n    Flag[\"Eritrea\"] = \"er\";\n    Flag[\"Spain\"] = \"es\";\n    Flag[\"Estonia\"] = \"ee\";\n    Flag[\"Ethiopia\"] = \"et\";\n    Flag[\"Finland\"] = \"fi\";\n    Flag[\"Fiji\"] = \"fj\";\n    Flag[\"France\"] = \"fr\";\n    Flag[\"MicronesiaFederatedStatesOf\"] = \"fm\";\n    Flag[\"Gabon\"] = \"ga\";\n    Flag[\"UnitedKingdom\"] = \"gb\";\n    Flag[\"Georgia\"] = \"ge\";\n    Flag[\"Ghana\"] = \"gh\";\n    Flag[\"Guinea\"] = \"gn\";\n    Flag[\"Gambia\"] = \"gm\";\n    Flag[\"GuineaBissau\"] = \"gw\";\n    Flag[\"EquatorialGuinea\"] = \"gq\";\n    Flag[\"Greece\"] = \"gr\";\n    Flag[\"Grenada\"] = \"gd\";\n    Flag[\"Guatemala\"] = \"gt\";\n    Flag[\"Guyana\"] = \"gy\";\n    Flag[\"Honduras\"] = \"hn\";\n    Flag[\"Croatia\"] = \"hr\";\n    Flag[\"Haiti\"] = \"ht\";\n    Flag[\"Hungary\"] = \"hu\";\n    Flag[\"Indonesia\"] = \"id\";\n    Flag[\"India\"] = \"in\";\n    Flag[\"Ireland\"] = \"ie\";\n    Flag[\"IranIslamicRepublicOf\"] = \"ir\";\n    Flag[\"Iraq\"] = \"iq\";\n    Flag[\"Iceland\"] = \"is\";\n    Flag[\"Israel\"] = \"il\";\n    Flag[\"Italy\"] = \"it\";\n    Flag[\"Jamaica\"] = \"jm\";\n    Flag[\"Jordan\"] = \"jo\";\n    Flag[\"Japan\"] = \"jp\";\n    Flag[\"Kazakhstan\"] = \"kz\";\n    Flag[\"Kenya\"] = \"ke\";\n    Flag[\"Kyrgyzstan\"] = \"kg\";\n    Flag[\"Cambodia\"] = \"kh\";\n    Flag[\"Kiribati\"] = \"ki\";\n    Flag[\"SaintKittsAndNevis\"] = \"kn\";\n    Flag[\"SouthKorea\"] = \"kr\";\n    Flag[\"Kuwait\"] = \"kw\";\n    Flag[\"LaoPeopleSDemocraticRepublic\"] = \"la\";\n    Flag[\"Lebanon\"] = \"lb\";\n    Flag[\"Liberia\"] = \"lr\";\n    Flag[\"Libya\"] = \"ly\";\n    Flag[\"SaintLucia\"] = \"lc\";\n    Flag[\"Liechtenstein\"] = \"li\";\n    Flag[\"SriLanka\"] = \"lk\";\n    Flag[\"Lesotho\"] = \"ls\";\n    Flag[\"Lithuania\"] = \"lt\";\n    Flag[\"Luxembourg\"] = \"lu\";\n    Flag[\"Latvia\"] = \"lv\";\n    Flag[\"Morocco\"] = \"ma\";\n    Flag[\"Monaco\"] = \"mc\";\n    Flag[\"Moldova\"] = \"md\";\n    Flag[\"Madagascar\"] = \"mg\";\n    Flag[\"Maldives\"] = \"mv\";\n    Flag[\"Mexico\"] = \"mx\";\n    Flag[\"MarshallIslands\"] = \"mh\";\n    Flag[\"NorthMacedonia\"] = \"mk\";\n    Flag[\"Mali\"] = \"ml\";\n    Flag[\"Malta\"] = \"mt\";\n    Flag[\"Myanmar\"] = \"mm\";\n    Flag[\"Montenegro\"] = \"me\";\n    Flag[\"Mongolia\"] = \"mn\";\n    Flag[\"Mozambique\"] = \"mz\";\n    Flag[\"Mauritania\"] = \"mr\";\n    Flag[\"Mauritius\"] = \"mu\";\n    Flag[\"Malawi\"] = \"mw\";\n    Flag[\"Malaysia\"] = \"my\";\n    Flag[\"Namibia\"] = \"na\";\n    Flag[\"Niger\"] = \"ne\";\n    Flag[\"Nigeria\"] = \"ng\";\n    Flag[\"Nicaragua\"] = \"ni\";\n    Flag[\"Netherlands\"] = \"nl\";\n    Flag[\"Norway\"] = \"no\";\n    Flag[\"Nepal\"] = \"np\";\n    Flag[\"Nauru\"] = \"nr\";\n    Flag[\"NewZealand\"] = \"nz\";\n    Flag[\"Oman\"] = \"om\";\n    Flag[\"Pakistan\"] = \"pk\";\n    Flag[\"Panama\"] = \"pa\";\n    Flag[\"Peru\"] = \"pe\";\n    Flag[\"Philippines\"] = \"ph\";\n    Flag[\"Palau\"] = \"pw\";\n    Flag[\"PapuaNewGuinea\"] = \"pg\";\n    Flag[\"Poland\"] = \"pl\";\n    Flag[\"FrenchPolynesia\"] = \"pf\";\n    Flag[\"NorthKorea\"] = \"kp\";\n    Flag[\"Portugal\"] = \"pt\";\n    Flag[\"Paraguay\"] = \"py\";\n    Flag[\"Qatar\"] = \"qa\";\n    Flag[\"Romania\"] = \"ro\";\n    Flag[\"Russia\"] = \"ru\";\n    Flag[\"Rwanda\"] = \"rw\";\n    Flag[\"SaudiArabia\"] = \"sa\";\n    Flag[\"Sudan\"] = \"sd\";\n    Flag[\"Senegal\"] = \"sn\";\n    Flag[\"Singapore\"] = \"sg\";\n    Flag[\"SolomonIslands\"] = \"sb\";\n    Flag[\"SierraLeone\"] = \"sl\";\n    Flag[\"ElSalvador\"] = \"sv\";\n    Flag[\"SanMarino\"] = \"sm\";\n    Flag[\"Somalia\"] = \"so\";\n    Flag[\"Serbia\"] = \"rs\";\n    Flag[\"SouthSudan\"] = \"ss\";\n    Flag[\"SaoTomeAndPrincipe\"] = \"st\";\n    Flag[\"Suriname\"] = \"sr\";\n    Flag[\"Slovakia\"] = \"sk\";\n    Flag[\"Slovenia\"] = \"si\";\n    Flag[\"Sweden\"] = \"se\";\n    Flag[\"Eswatini\"] = \"sz\";\n    Flag[\"Seychelles\"] = \"sc\";\n    Flag[\"Syria\"] = \"sy\";\n    Flag[\"Chad\"] = \"td\";\n    Flag[\"Togo\"] = \"tg\";\n    Flag[\"Thailand\"] = \"th\";\n    Flag[\"Tajikistan\"] = \"tj\";\n    Flag[\"Turkmenistan\"] = \"tm\";\n    Flag[\"TimorLeste\"] = \"tl\";\n    Flag[\"Tonga\"] = \"to\";\n    Flag[\"TrinidadAndTobago\"] = \"tt\";\n    Flag[\"Tunisia\"] = \"tn\";\n    Flag[\"Turkey\"] = \"tr\";\n    Flag[\"Tuvalu\"] = \"tv\";\n    Flag[\"Tanzania\"] = \"tz\";\n    Flag[\"Uganda\"] = \"ug\";\n    Flag[\"Ukraine\"] = \"ua\";\n    Flag[\"Uruguay\"] = \"uy\";\n    Flag[\"UnitedStates\"] = \"us\";\n    Flag[\"Uzbekistan\"] = \"uz\";\n    Flag[\"VaticanCity\"] = \"va\";\n    Flag[\"SaintVincentAndTheGrenadines\"] = \"vc\";\n    Flag[\"Venezuela\"] = \"ve\";\n    Flag[\"Vietnam\"] = \"vn\";\n    Flag[\"Vanuatu\"] = \"vu\";\n    Flag[\"Samoa\"] = \"ws\";\n    Flag[\"Yemen\"] = \"ye\";\n    Flag[\"SouthAfrica\"] = \"za\";\n    Flag[\"Zambia\"] = \"zm\";\n    Flag[\"Zimbabwe\"] = \"zw\";\n})(Flag || (Flag = {}));\n\nvar ExecutionMethod;\n(function (ExecutionMethod) {\n    ExecutionMethod[\"GET\"] = \"GET\";\n    ExecutionMethod[\"POST\"] = \"POST\";\n    ExecutionMethod[\"PUT\"] = \"PUT\";\n    ExecutionMethod[\"PATCH\"] = \"PATCH\";\n    ExecutionMethod[\"DELETE\"] = \"DELETE\";\n    ExecutionMethod[\"OPTIONS\"] = \"OPTIONS\";\n    ExecutionMethod[\"HEAD\"] = \"HEAD\";\n})(ExecutionMethod || (ExecutionMethod = {}));\n\nvar ImageGravity;\n(function (ImageGravity) {\n    ImageGravity[\"Center\"] = \"center\";\n    ImageGravity[\"Topleft\"] = \"top-left\";\n    ImageGravity[\"Top\"] = \"top\";\n    ImageGravity[\"Topright\"] = \"top-right\";\n    ImageGravity[\"Left\"] = \"left\";\n    ImageGravity[\"Right\"] = \"right\";\n    ImageGravity[\"Bottomleft\"] = \"bottom-left\";\n    ImageGravity[\"Bottom\"] = \"bottom\";\n    ImageGravity[\"Bottomright\"] = \"bottom-right\";\n})(ImageGravity || (ImageGravity = {}));\n\nvar ImageFormat;\n(function (ImageFormat) {\n    ImageFormat[\"Jpg\"] = \"jpg\";\n    ImageFormat[\"Jpeg\"] = \"jpeg\";\n    ImageFormat[\"Png\"] = \"png\";\n    ImageFormat[\"Webp\"] = \"webp\";\n    ImageFormat[\"Heic\"] = \"heic\";\n    ImageFormat[\"Avif\"] = \"avif\";\n    ImageFormat[\"Gif\"] = \"gif\";\n})(ImageFormat || (ImageFormat = {}));\n\n\n//# sourceMappingURL=sdk.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBwd3JpdGUvZGlzdC9lc20vc2RrLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxZQUFZO0FBQ3ZCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsWUFBWTtBQUN2QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxZQUFZO0FBQ3ZCLGFBQWE7QUFD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QUFDQTtBQUNBLHNEQUFzRCxLQUFLLFlBQVksS0FBSztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsS0FBSyxZQUFZLEtBQUs7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsS0FBSyxZQUFZLEtBQUs7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsS0FBSyxZQUFZLEtBQUs7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVMsWUFBWSxTQUFTO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFVBQVUsWUFBWSxVQUFVO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsVUFBVSxZQUFZLFVBQVU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsVUFBVSxZQUFZLFVBQVU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTLGlCQUFpQixTQUFTO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVMsaUJBQWlCLFNBQVM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFNBQVMsWUFBWSxTQUFTO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEtBQUssWUFBWSxLQUFLO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsS0FBSyxZQUFZLEtBQUs7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxLQUFLLFlBQVksS0FBSztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU8sWUFBWSxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU8sWUFBWSxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTyx3QkFBd0IsT0FBTztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU8sd0JBQXdCLE9BQU87QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9COztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQzs7QUFFNFA7QUFDL1IiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcRXN0ZWJhblxcRGVza3RvcFxcUHJveWVjdG9zV2ViXFxHYW5hZGVyaWEgM1xcbm9kZV9tb2R1bGVzXFxhcHB3cml0ZVxcZGlzdFxcZXNtXFxzZGsuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHRvIGdlbmVyYXRlIHF1ZXJ5IHN0cmluZ3MuXG4gKi9cbmNsYXNzIFF1ZXJ5IHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgUXVlcnkgY2xhc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG4gICAgICogQHBhcmFtIHtBdHRyaWJ1dGVzVHlwZXN9IGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSB7UXVlcnlUeXBlc30gdmFsdWVzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWV0aG9kLCBhdHRyaWJ1dGUsIHZhbHVlcykge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGUgPSBhdHRyaWJ1dGU7XG4gICAgICAgIGlmICh2YWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBxdWVyeSBvYmplY3QgdG8gYSBKU09OIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgICAgICAgYXR0cmlidXRlOiB0aGlzLmF0dHJpYnV0ZSxcbiAgICAgICAgICAgIHZhbHVlczogdGhpcy52YWx1ZXMsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgaXMgZXF1YWwgdG8gdmFsdWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtRdWVyeVR5cGVzfSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkuZXF1YWwgPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT4gbmV3IFF1ZXJ5KFwiZXF1YWxcIiwgYXR0cmlidXRlLCB2YWx1ZSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgaXMgbm90IGVxdWFsIHRvIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7UXVlcnlUeXBlc30gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5Lm5vdEVxdWFsID0gKGF0dHJpYnV0ZSwgdmFsdWUpID0+IG5ldyBRdWVyeShcIm5vdEVxdWFsXCIsIGF0dHJpYnV0ZSwgdmFsdWUpLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgYXR0cmlidXRlIGlzIGxlc3MgdGhhbiB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge1F1ZXJ5VHlwZXN9IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5sZXNzVGhhbiA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PiBuZXcgUXVlcnkoXCJsZXNzVGhhblwiLCBhdHRyaWJ1dGUsIHZhbHVlKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGF0dHJpYnV0ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdmFsdWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtRdWVyeVR5cGVzfSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkubGVzc1RoYW5FcXVhbCA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PiBuZXcgUXVlcnkoXCJsZXNzVGhhbkVxdWFsXCIsIGF0dHJpYnV0ZSwgdmFsdWUpLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgYXR0cmlidXRlIGlzIGdyZWF0ZXIgdGhhbiB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge1F1ZXJ5VHlwZXN9IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5ncmVhdGVyVGhhbiA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PiBuZXcgUXVlcnkoXCJncmVhdGVyVGhhblwiLCBhdHRyaWJ1dGUsIHZhbHVlKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGF0dHJpYnV0ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdmFsdWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtRdWVyeVR5cGVzfSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkuZ3JlYXRlclRoYW5FcXVhbCA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PiBuZXcgUXVlcnkoXCJncmVhdGVyVGhhbkVxdWFsXCIsIGF0dHJpYnV0ZSwgdmFsdWUpLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgYXR0cmlidXRlIGlzIG51bGwuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkuaXNOdWxsID0gKGF0dHJpYnV0ZSkgPT4gbmV3IFF1ZXJ5KFwiaXNOdWxsXCIsIGF0dHJpYnV0ZSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgaXMgbm90IG51bGwuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkuaXNOb3ROdWxsID0gKGF0dHJpYnV0ZSkgPT4gbmV3IFF1ZXJ5KFwiaXNOb3ROdWxsXCIsIGF0dHJpYnV0ZSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgaXMgYmV0d2VlbiBzdGFydCBhbmQgZW5kIChpbmNsdXNpdmUpLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBzdGFydFxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IGVuZFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkuYmV0d2VlbiA9IChhdHRyaWJ1dGUsIHN0YXJ0LCBlbmQpID0+IG5ldyBRdWVyeShcImJldHdlZW5cIiwgYXR0cmlidXRlLCBbc3RhcnQsIGVuZF0pLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgYXR0cmlidXRlIHN0YXJ0cyB3aXRoIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkuc3RhcnRzV2l0aCA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PiBuZXcgUXVlcnkoXCJzdGFydHNXaXRoXCIsIGF0dHJpYnV0ZSwgdmFsdWUpLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgYXR0cmlidXRlIGVuZHMgd2l0aCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LmVuZHNXaXRoID0gKGF0dHJpYnV0ZSwgdmFsdWUpID0+IG5ldyBRdWVyeShcImVuZHNXaXRoXCIsIGF0dHJpYnV0ZSwgdmFsdWUpLnRvU3RyaW5nKCk7XG4vKipcbiAqIFNwZWNpZnkgd2hpY2ggYXR0cmlidXRlcyBzaG91bGQgYmUgcmV0dXJuZWQgYnkgdGhlIEFQSSBjYWxsLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nW119IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LnNlbGVjdCA9IChhdHRyaWJ1dGVzKSA9PiBuZXcgUXVlcnkoXCJzZWxlY3RcIiwgdW5kZWZpbmVkLCBhdHRyaWJ1dGVzKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIGJ5IHNlYXJjaGluZyBhdHRyaWJ1dGUgZm9yIHZhbHVlLlxuICogQSBmdWxsdGV4dCBpbmRleCBvbiBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQgZm9yIHRoaXMgcXVlcnkgdG8gd29yay5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LnNlYXJjaCA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PiBuZXcgUXVlcnkoXCJzZWFyY2hcIiwgYXR0cmlidXRlLCB2YWx1ZSkudG9TdHJpbmcoKTtcbi8qKlxuICogU29ydCByZXN1bHRzIGJ5IGF0dHJpYnV0ZSBkZXNjZW5kaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5Lm9yZGVyRGVzYyA9IChhdHRyaWJ1dGUpID0+IG5ldyBRdWVyeShcIm9yZGVyRGVzY1wiLCBhdHRyaWJ1dGUpLnRvU3RyaW5nKCk7XG4vKipcbiAqIFNvcnQgcmVzdWx0cyBieSBhdHRyaWJ1dGUgYXNjZW5kaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5Lm9yZGVyQXNjID0gKGF0dHJpYnV0ZSkgPT4gbmV3IFF1ZXJ5KFwib3JkZXJBc2NcIiwgYXR0cmlidXRlKS50b1N0cmluZygpO1xuLyoqXG4gKiBTb3J0IHJlc3VsdHMgcmFuZG9tbHkuXG4gKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkub3JkZXJSYW5kb20gPSAoKSA9PiBuZXcgUXVlcnkoXCJvcmRlclJhbmRvbVwiKS50b1N0cmluZygpO1xuLyoqXG4gKiBSZXR1cm4gcmVzdWx0cyBhZnRlciBkb2N1bWVudElkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkb2N1bWVudElkXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5jdXJzb3JBZnRlciA9IChkb2N1bWVudElkKSA9PiBuZXcgUXVlcnkoXCJjdXJzb3JBZnRlclwiLCB1bmRlZmluZWQsIGRvY3VtZW50SWQpLnRvU3RyaW5nKCk7XG4vKipcbiAqIFJldHVybiByZXN1bHRzIGJlZm9yZSBkb2N1bWVudElkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkb2N1bWVudElkXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5jdXJzb3JCZWZvcmUgPSAoZG9jdW1lbnRJZCkgPT4gbmV3IFF1ZXJ5KFwiY3Vyc29yQmVmb3JlXCIsIHVuZGVmaW5lZCwgZG9jdW1lbnRJZCkudG9TdHJpbmcoKTtcbi8qKlxuICogUmV0dXJuIG9ubHkgbGltaXQgcmVzdWx0cy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbGltaXRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LmxpbWl0ID0gKGxpbWl0KSA9PiBuZXcgUXVlcnkoXCJsaW1pdFwiLCB1bmRlZmluZWQsIGxpbWl0KS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIGJ5IHNraXBwaW5nIHRoZSBmaXJzdCBvZmZzZXQgcmVzdWx0cy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5vZmZzZXQgPSAob2Zmc2V0KSA9PiBuZXcgUXVlcnkoXCJvZmZzZXRcIiwgdW5kZWZpbmVkLCBvZmZzZXQpLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgYXR0cmlidXRlIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXX0gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LmNvbnRhaW5zID0gKGF0dHJpYnV0ZSwgdmFsdWUpID0+IG5ldyBRdWVyeShcImNvbnRhaW5zXCIsIGF0dHJpYnV0ZSwgdmFsdWUpLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgYXR0cmlidXRlIGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZyB8IGFueVtdfSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkubm90Q29udGFpbnMgPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT4gbmV3IFF1ZXJ5KFwibm90Q29udGFpbnNcIiwgYXR0cmlidXRlLCB2YWx1ZSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyBieSBzZWFyY2hpbmcgYXR0cmlidXRlIGZvciB2YWx1ZSAoaW52ZXJzZSBvZiBzZWFyY2gpLlxuICogQSBmdWxsdGV4dCBpbmRleCBvbiBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQgZm9yIHRoaXMgcXVlcnkgdG8gd29yay5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5Lm5vdFNlYXJjaCA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PiBuZXcgUXVlcnkoXCJub3RTZWFyY2hcIiwgYXR0cmlidXRlLCB2YWx1ZSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgaXMgbm90IGJldHdlZW4gc3RhcnQgYW5kIGVuZCAoZXhjbHVzaXZlKS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gc3RhcnRcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBlbmRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5Lm5vdEJldHdlZW4gPSAoYXR0cmlidXRlLCBzdGFydCwgZW5kKSA9PiBuZXcgUXVlcnkoXCJub3RCZXR3ZWVuXCIsIGF0dHJpYnV0ZSwgW3N0YXJ0LCBlbmRdKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGF0dHJpYnV0ZSBkb2VzIG5vdCBzdGFydCB3aXRoIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkubm90U3RhcnRzV2l0aCA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PiBuZXcgUXVlcnkoXCJub3RTdGFydHNXaXRoXCIsIGF0dHJpYnV0ZSwgdmFsdWUpLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgYXR0cmlidXRlIGRvZXMgbm90IGVuZCB3aXRoIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkubm90RW5kc1dpdGggPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT4gbmV3IFF1ZXJ5KFwibm90RW5kc1dpdGhcIiwgYXR0cmlidXRlLCB2YWx1ZSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBkb2N1bWVudCB3YXMgY3JlYXRlZCBiZWZvcmUgZGF0ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LmNyZWF0ZWRCZWZvcmUgPSAodmFsdWUpID0+IG5ldyBRdWVyeShcImNyZWF0ZWRCZWZvcmVcIiwgdW5kZWZpbmVkLCB2YWx1ZSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBkb2N1bWVudCB3YXMgY3JlYXRlZCBhZnRlciBkYXRlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkuY3JlYXRlZEFmdGVyID0gKHZhbHVlKSA9PiBuZXcgUXVlcnkoXCJjcmVhdGVkQWZ0ZXJcIiwgdW5kZWZpbmVkLCB2YWx1ZSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBkb2N1bWVudCB3YXMgY3JlYXRlZCBiZXR3ZWVuIGRhdGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdGFydFxuICogQHBhcmFtIHtzdHJpbmd9IGVuZFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkuY3JlYXRlZEJldHdlZW4gPSAoc3RhcnQsIGVuZCkgPT4gbmV3IFF1ZXJ5KFwiY3JlYXRlZEJldHdlZW5cIiwgdW5kZWZpbmVkLCBbc3RhcnQsIGVuZF0pLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgZG9jdW1lbnQgd2FzIHVwZGF0ZWQgYmVmb3JlIGRhdGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS51cGRhdGVkQmVmb3JlID0gKHZhbHVlKSA9PiBuZXcgUXVlcnkoXCJ1cGRhdGVkQmVmb3JlXCIsIHVuZGVmaW5lZCwgdmFsdWUpLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgZG9jdW1lbnQgd2FzIHVwZGF0ZWQgYWZ0ZXIgZGF0ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LnVwZGF0ZWRBZnRlciA9ICh2YWx1ZSkgPT4gbmV3IFF1ZXJ5KFwidXBkYXRlZEFmdGVyXCIsIHVuZGVmaW5lZCwgdmFsdWUpLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgZG9jdW1lbnQgd2FzIHVwZGF0ZWQgYmV0d2VlbiBkYXRlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RhcnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LnVwZGF0ZWRCZXR3ZWVuID0gKHN0YXJ0LCBlbmQpID0+IG5ldyBRdWVyeShcInVwZGF0ZWRCZXR3ZWVuXCIsIHVuZGVmaW5lZCwgW3N0YXJ0LCBlbmRdKS50b1N0cmluZygpO1xuLyoqXG4gKiBDb21iaW5lIG11bHRpcGxlIHF1ZXJpZXMgdXNpbmcgbG9naWNhbCBPUiBvcGVyYXRvci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBxdWVyaWVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5vciA9IChxdWVyaWVzKSA9PiBuZXcgUXVlcnkoXCJvclwiLCB1bmRlZmluZWQsIHF1ZXJpZXMubWFwKChxdWVyeSkgPT4gSlNPTi5wYXJzZShxdWVyeSkpKS50b1N0cmluZygpO1xuLyoqXG4gKiBDb21iaW5lIG11bHRpcGxlIHF1ZXJpZXMgdXNpbmcgbG9naWNhbCBBTkQgb3BlcmF0b3IuXG4gKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkuYW5kID0gKHF1ZXJpZXMpID0+IG5ldyBRdWVyeShcImFuZFwiLCB1bmRlZmluZWQsIHF1ZXJpZXMubWFwKChxdWVyeSkgPT4gSlNPTi5wYXJzZShxdWVyeSkpKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGF0dHJpYnV0ZSBpcyBhdCBhIHNwZWNpZmljIGRpc3RhbmNlIGZyb20gdGhlIGdpdmVuIGNvb3JkaW5hdGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7YW55W119IHZhbHVlc1xuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG1ldGVyc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkuZGlzdGFuY2VFcXVhbCA9IChhdHRyaWJ1dGUsIHZhbHVlcywgZGlzdGFuY2UsIG1ldGVycyA9IHRydWUpID0+IG5ldyBRdWVyeShcImRpc3RhbmNlRXF1YWxcIiwgYXR0cmlidXRlLCBbW3ZhbHVlcywgZGlzdGFuY2UsIG1ldGVyc11dKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGF0dHJpYnV0ZSBpcyBub3QgYXQgYSBzcGVjaWZpYyBkaXN0YW5jZSBmcm9tIHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge2FueVtdfSB2YWx1ZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICogQHBhcmFtIHtib29sZWFufSBtZXRlcnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LmRpc3RhbmNlTm90RXF1YWwgPSAoYXR0cmlidXRlLCB2YWx1ZXMsIGRpc3RhbmNlLCBtZXRlcnMgPSB0cnVlKSA9PiBuZXcgUXVlcnkoXCJkaXN0YW5jZU5vdEVxdWFsXCIsIGF0dHJpYnV0ZSwgW1t2YWx1ZXMsIGRpc3RhbmNlLCBtZXRlcnNdXSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgaXMgYXQgYSBkaXN0YW5jZSBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge2FueVtdfSB2YWx1ZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICogQHBhcmFtIHtib29sZWFufSBtZXRlcnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LmRpc3RhbmNlR3JlYXRlclRoYW4gPSAoYXR0cmlidXRlLCB2YWx1ZXMsIGRpc3RhbmNlLCBtZXRlcnMgPSB0cnVlKSA9PiBuZXcgUXVlcnkoXCJkaXN0YW5jZUdyZWF0ZXJUaGFuXCIsIGF0dHJpYnV0ZSwgW1t2YWx1ZXMsIGRpc3RhbmNlLCBtZXRlcnNdXSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgaXMgYXQgYSBkaXN0YW5jZSBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge2FueVtdfSB2YWx1ZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICogQHBhcmFtIHtib29sZWFufSBtZXRlcnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LmRpc3RhbmNlTGVzc1RoYW4gPSAoYXR0cmlidXRlLCB2YWx1ZXMsIGRpc3RhbmNlLCBtZXRlcnMgPSB0cnVlKSA9PiBuZXcgUXVlcnkoXCJkaXN0YW5jZUxlc3NUaGFuXCIsIGF0dHJpYnV0ZSwgW1t2YWx1ZXMsIGRpc3RhbmNlLCBtZXRlcnNdXSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgaW50ZXJzZWN0cyB3aXRoIHRoZSBnaXZlbiBnZW9tZXRyeS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge2FueVtdfSB2YWx1ZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LmludGVyc2VjdHMgPSAoYXR0cmlidXRlLCB2YWx1ZXMpID0+IG5ldyBRdWVyeShcImludGVyc2VjdHNcIiwgYXR0cmlidXRlLCBbdmFsdWVzXSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgZG9lcyBub3QgaW50ZXJzZWN0IHdpdGggdGhlIGdpdmVuIGdlb21ldHJ5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7YW55W119IHZhbHVlc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkubm90SW50ZXJzZWN0cyA9IChhdHRyaWJ1dGUsIHZhbHVlcykgPT4gbmV3IFF1ZXJ5KFwibm90SW50ZXJzZWN0c1wiLCBhdHRyaWJ1dGUsIFt2YWx1ZXNdKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGF0dHJpYnV0ZSBjcm9zc2VzIHRoZSBnaXZlbiBnZW9tZXRyeS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge2FueVtdfSB2YWx1ZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LmNyb3NzZXMgPSAoYXR0cmlidXRlLCB2YWx1ZXMpID0+IG5ldyBRdWVyeShcImNyb3NzZXNcIiwgYXR0cmlidXRlLCBbdmFsdWVzXSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgZG9lcyBub3QgY3Jvc3MgdGhlIGdpdmVuIGdlb21ldHJ5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7YW55W119IHZhbHVlc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkubm90Q3Jvc3NlcyA9IChhdHRyaWJ1dGUsIHZhbHVlcykgPT4gbmV3IFF1ZXJ5KFwibm90Q3Jvc3Nlc1wiLCBhdHRyaWJ1dGUsIFt2YWx1ZXNdKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGF0dHJpYnV0ZSBvdmVybGFwcyB3aXRoIHRoZSBnaXZlbiBnZW9tZXRyeS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge2FueVtdfSB2YWx1ZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5Lm92ZXJsYXBzID0gKGF0dHJpYnV0ZSwgdmFsdWVzKSA9PiBuZXcgUXVlcnkoXCJvdmVybGFwc1wiLCBhdHRyaWJ1dGUsIFt2YWx1ZXNdKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGF0dHJpYnV0ZSBkb2VzIG5vdCBvdmVybGFwIHdpdGggdGhlIGdpdmVuIGdlb21ldHJ5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7YW55W119IHZhbHVlc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkubm90T3ZlcmxhcHMgPSAoYXR0cmlidXRlLCB2YWx1ZXMpID0+IG5ldyBRdWVyeShcIm5vdE92ZXJsYXBzXCIsIGF0dHJpYnV0ZSwgW3ZhbHVlc10pLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgYXR0cmlidXRlIHRvdWNoZXMgdGhlIGdpdmVuIGdlb21ldHJ5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7YW55W119IHZhbHVlc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkudG91Y2hlcyA9IChhdHRyaWJ1dGUsIHZhbHVlcykgPT4gbmV3IFF1ZXJ5KFwidG91Y2hlc1wiLCBhdHRyaWJ1dGUsIFt2YWx1ZXNdKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGF0dHJpYnV0ZSBkb2VzIG5vdCB0b3VjaCB0aGUgZ2l2ZW4gZ2VvbWV0cnkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHthbnlbXX0gdmFsdWVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5ub3RUb3VjaGVzID0gKGF0dHJpYnV0ZSwgdmFsdWVzKSA9PiBuZXcgUXVlcnkoXCJub3RUb3VjaGVzXCIsIGF0dHJpYnV0ZSwgW3ZhbHVlc10pLnRvU3RyaW5nKCk7XG5cbi8qKlxuICogRXhjZXB0aW9uIHRocm93biBieSB0aGUgIHBhY2thZ2VcbiAqL1xuY2xhc3MgQXBwd3JpdGVFeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBBcHB3cml0ZSBFeGNlcHRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlIC0gVGhlIGVycm9yIGNvZGUuIERlZmF1bHQgaXMgMC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSBlcnJvciB0eXBlLiBEZWZhdWx0IGlzIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVzcG9uc2UgLSBUaGUgcmVzcG9uc2Ugc3RyaW5nLiBEZWZhdWx0IGlzIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjb2RlID0gMCwgdHlwZSA9ICcnLCByZXNwb25zZSA9ICcnKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXBwd3JpdGVFeGNlcHRpb24nO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgfVxufVxuLyoqXG4gKiBDbGllbnQgdGhhdCBoYW5kbGVzIHJlcXVlc3RzIHRvIEFwcHdyaXRlXG4gKi9cbmNsYXNzIENsaWVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIb2xkcyBjb25maWd1cmF0aW9uIHN1Y2ggYXMgcHJvamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAgICAgZW5kcG9pbnQ6ICdodHRwczovL2Nsb3VkLmFwcHdyaXRlLmlvL3YxJyxcbiAgICAgICAgICAgIGVuZHBvaW50UmVhbHRpbWU6ICcnLFxuICAgICAgICAgICAgcHJvamVjdDogJycsXG4gICAgICAgICAgICBqd3Q6ICcnLFxuICAgICAgICAgICAgbG9jYWxlOiAnJyxcbiAgICAgICAgICAgIHNlc3Npb246ICcnLFxuICAgICAgICAgICAgZGV2a2V5OiAnJyxcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1c3RvbSBoZWFkZXJzIGZvciBBUEkgcmVxdWVzdHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSB7XG4gICAgICAgICAgICAneC1zZGstbmFtZSc6ICdXZWInLFxuICAgICAgICAgICAgJ3gtc2RrLXBsYXRmb3JtJzogJ2NsaWVudCcsXG4gICAgICAgICAgICAneC1zZGstbGFuZ3VhZ2UnOiAnd2ViJyxcbiAgICAgICAgICAgICd4LXNkay12ZXJzaW9uJzogJzIxLjAuMCcsXG4gICAgICAgICAgICAnWC1BcHB3cml0ZS1SZXNwb25zZS1Gb3JtYXQnOiAnMS44LjAnLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlYWx0aW1lID0ge1xuICAgICAgICAgICAgc29ja2V0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0aW1lb3V0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBoZWFydGJlYXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVybDogJycsXG4gICAgICAgICAgICBjaGFubmVsczogbmV3IFNldCgpLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uczogbmV3IE1hcCgpLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uc0NvdW50ZXI6IDAsXG4gICAgICAgICAgICByZWNvbm5lY3Q6IHRydWUsXG4gICAgICAgICAgICByZWNvbm5lY3RBdHRlbXB0czogMCxcbiAgICAgICAgICAgIGxhc3RNZXNzYWdlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb25uZWN0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVhbHRpbWUudGltZW91dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS50aW1lb3V0ID0gd2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lLmNyZWF0ZVNvY2tldCgpO1xuICAgICAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRUaW1lb3V0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5yZWFsdGltZS5yZWNvbm5lY3RBdHRlbXB0cyA8IDU6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLnJlYWx0aW1lLnJlY29ubmVjdEF0dGVtcHRzIDwgMTU6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gNTAwMDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLnJlYWx0aW1lLnJlY29ubmVjdEF0dGVtcHRzIDwgMTAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEwMDAwO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDYwMDAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjcmVhdGVIZWFydGJlYXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFsdGltZS5oZWFydGJlYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVhbHRpbWUuaGVhcnRiZWF0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5oZWFydGJlYXQgPSB3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHRoaXMucmVhbHRpbWUuc29ja2V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncGluZydcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0sIDIwMDAwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjcmVhdGVTb2NrZXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFsdGltZS5jaGFubmVscy5zaXplIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lLnJlY29ubmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLnJlYWx0aW1lLnNvY2tldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbHMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgICAgICAgICAgY2hhbm5lbHMuc2V0KCdwcm9qZWN0JywgdGhpcy5jb25maWcucHJvamVjdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5jaGFubmVscy5mb3JFYWNoKGNoYW5uZWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVscy5hcHBlbmQoJ2NoYW5uZWxzW10nLCBjaGFubmVsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmNvbmZpZy5lbmRwb2ludFJlYWx0aW1lICsgJy9yZWFsdGltZT8nICsgY2hhbm5lbHMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAodXJsICE9PSB0aGlzLnJlYWx0aW1lLnVybCB8fCAvLyBDaGVjayBpZiBVUkwgaXMgcHJlc2VudFxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5yZWFsdGltZS5zb2NrZXQgfHwgLy8gQ2hlY2sgaWYgV2ViU29ja2V0IGhhcyBub3QgYmVlbiBjcmVhdGVkXG4gICAgICAgICAgICAgICAgICAgICgoX2IgPSB0aGlzLnJlYWx0aW1lLnNvY2tldCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlYWR5U3RhdGUpID4gV2ViU29ja2V0Lk9QRU4gLy8gQ2hlY2sgaWYgV2ViU29ja2V0IGlzIENMT1NJTkcgKDMpIG9yIENMT1NFRCAoNClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhbHRpbWUuc29ja2V0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoKF9jID0gdGhpcy5yZWFsdGltZS5zb2NrZXQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yZWFkeVN0YXRlKSA8IFdlYlNvY2tldC5DTE9TSU5HIC8vIENsb3NlIFdlYlNvY2tldCBpZiBpdCBpcyBDT05ORUNUSU5HICgwKSBvciBPUEVOICgxKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWUucmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lLnNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWUudXJsID0gdXJsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lLnNvY2tldCA9IG5ldyBXZWJTb2NrZXQodXJsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMucmVhbHRpbWUub25NZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIF9ldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuY3JlYXRlSGVhcnRiZWF0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlYWx0aW1lLnJlY29ubmVjdCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoKF9iID0gKF9hID0gdGhpcy5yZWFsdGltZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhc3RNZXNzYWdlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudHlwZSkgPT09ICdlcnJvcicgJiYgLy8gQ2hlY2sgaWYgbGFzdCBtZXNzYWdlIHdhcyBvZiB0eXBlIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoX2MgPSB0aGlzLnJlYWx0aW1lKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubGFzdE1lc3NhZ2UuZGF0YSkuY29kZSA9PT0gMTAwOCAvLyBDaGVjayBmb3IgcG9saWN5IHZpb2xhdGlvbiAxMDA4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWUucmVjb25uZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gdGhpcy5yZWFsdGltZS5nZXRUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBSZWFsdGltZSBnb3QgZGlzY29ubmVjdGVkLiBSZWNvbm5lY3Qgd2lsbCBiZSBhdHRlbXB0ZWQgaW4gJHt0aW1lb3V0IC8gMTAwMH0gc2Vjb25kcy5gLCBldmVudC5yZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5yZWNvbm5lY3RBdHRlbXB0cysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuY3JlYXRlU29ja2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uTWVzc2FnZTogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5sYXN0TWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvb2tpZSA9IEpTT04ucGFyc2UoKF9hID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKCdjb29raWVGYWxsYmFjaycpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAne30nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gY29va2llID09PSBudWxsIHx8IGNvb2tpZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29va2llW2BhX3Nlc3Npb25fJHt0aGlzLmNvbmZpZy5wcm9qZWN0fWBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VEYXRhID0gbWVzc2FnZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uICYmICFtZXNzYWdlRGF0YS51c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYiA9IHRoaXMucmVhbHRpbWUuc29ja2V0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2VuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYXV0aGVudGljYXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V2ZW50JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IG1lc3NhZ2UuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLmNoYW5uZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzU3Vic2NyaWJlZCA9IGRhdGEuY2hhbm5lbHMuc29tZShjaGFubmVsID0+IHRoaXMucmVhbHRpbWUuY2hhbm5lbHMuaGFzKGNoYW5uZWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1N1YnNjcmliZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YnNjcmlwdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5jaGFubmVscy5zb21lKGNoYW5uZWwgPT4gc3Vic2NyaXB0aW9uLmNoYW5uZWxzLmluY2x1ZGVzKGNoYW5uZWwpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc3Vic2NyaXB0aW9uLmNhbGxiYWNrKGRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncG9uZyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIEhhbmRsZSBwb25nIHJlc3BvbnNlIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG1lc3NhZ2UuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xlYW5VcDogY2hhbm5lbHMgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuY2hhbm5lbHMuZm9yRWFjaChjaGFubmVsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5uZWxzLmluY2x1ZGVzKGNoYW5uZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBBcnJheS5mcm9tKHRoaXMucmVhbHRpbWUuc3Vic2NyaXB0aW9ucykuc29tZSgoW19rZXksIHN1YnNjcmlwdGlvbl0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uLmNoYW5uZWxzLmluY2x1ZGVzKGNoYW5uZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5jaGFubmVscy5kZWxldGUoY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IEVuZHBvaW50XG4gICAgICpcbiAgICAgKiBZb3VyIHByb2plY3QgZW5kcG9pbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbmRwb2ludFxuICAgICAqXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgc2V0RW5kcG9pbnQoZW5kcG9pbnQpIHtcbiAgICAgICAgaWYgKCFlbmRwb2ludC5zdGFydHNXaXRoKCdodHRwOi8vJykgJiYgIWVuZHBvaW50LnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignSW52YWxpZCBlbmRwb2ludCBVUkw6ICcgKyBlbmRwb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25maWcuZW5kcG9pbnQgPSBlbmRwb2ludDtcbiAgICAgICAgdGhpcy5jb25maWcuZW5kcG9pbnRSZWFsdGltZSA9IGVuZHBvaW50LnJlcGxhY2UoJ2h0dHBzOi8vJywgJ3dzczovLycpLnJlcGxhY2UoJ2h0dHA6Ly8nLCAnd3M6Ly8nKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBSZWFsdGltZSBFbmRwb2ludFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVuZHBvaW50UmVhbHRpbWVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIHNldEVuZHBvaW50UmVhbHRpbWUoZW5kcG9pbnRSZWFsdGltZSkge1xuICAgICAgICBpZiAoIWVuZHBvaW50UmVhbHRpbWUuc3RhcnRzV2l0aCgnd3M6Ly8nKSAmJiAhZW5kcG9pbnRSZWFsdGltZS5zdGFydHNXaXRoKCd3c3M6Ly8nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdJbnZhbGlkIHJlYWx0aW1lIGVuZHBvaW50IFVSTDogJyArIGVuZHBvaW50UmVhbHRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29uZmlnLmVuZHBvaW50UmVhbHRpbWUgPSBlbmRwb2ludFJlYWx0aW1lO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IFByb2plY3RcbiAgICAgKlxuICAgICAqIFlvdXIgcHJvamVjdCBJRFxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHN0cmluZ1xuICAgICAqXG4gICAgICogQHJldHVybiB7dGhpc31cbiAgICAgKi9cbiAgICBzZXRQcm9qZWN0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaGVhZGVyc1snWC1BcHB3cml0ZS1Qcm9qZWN0J10gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5jb25maWcucHJvamVjdCA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IEpXVFxuICAgICAqXG4gICAgICogWW91ciBzZWNyZXQgSlNPTiBXZWIgVG9rZW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBzdHJpbmdcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3RoaXN9XG4gICAgICovXG4gICAgc2V0SldUKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaGVhZGVyc1snWC1BcHB3cml0ZS1KV1QnXSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNvbmZpZy5qd3QgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBMb2NhbGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBzdHJpbmdcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3RoaXN9XG4gICAgICovXG4gICAgc2V0TG9jYWxlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaGVhZGVyc1snWC1BcHB3cml0ZS1Mb2NhbGUnXSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNvbmZpZy5sb2NhbGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBTZXNzaW9uXG4gICAgICpcbiAgICAgKiBUaGUgdXNlciBzZXNzaW9uIHRvIGF1dGhlbnRpY2F0ZSB3aXRoXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgc3RyaW5nXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgICAqL1xuICAgIHNldFNlc3Npb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzWydYLUFwcHdyaXRlLVNlc3Npb24nXSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNvbmZpZy5zZXNzaW9uID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgRGV2S2V5XG4gICAgICpcbiAgICAgKiBZb3VyIHNlY3JldCBkZXYgQVBJIGtleVxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHN0cmluZ1xuICAgICAqXG4gICAgICogQHJldHVybiB7dGhpc31cbiAgICAgKi9cbiAgICBzZXREZXZLZXkodmFsdWUpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzWydYLUFwcHdyaXRlLURldi1LZXknXSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNvbmZpZy5kZXZrZXkgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgdG8gQXBwd3JpdGUgZXZlbnRzIGFuZCBwYXNzZXMgeW91IHRoZSBwYXlsb2FkIGluIHJlYWx0aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGNoYW5uZWxzXG4gICAgICogQ2hhbm5lbCB0byBzdWJzY3JpYmUgLSBwYXNzIGEgc2luZ2xlIGNoYW5uZWwgYXMgYSBzdHJpbmcgb3IgbXVsdGlwbGUgd2l0aCBhbiBhcnJheSBvZiBzdHJpbmdzLlxuICAgICAqXG4gICAgICogUG9zc2libGUgY2hhbm5lbHMgYXJlOlxuICAgICAqIC0gYWNjb3VudFxuICAgICAqIC0gY29sbGVjdGlvbnNcbiAgICAgKiAtIGNvbGxlY3Rpb25zLltJRF1cbiAgICAgKiAtIGNvbGxlY3Rpb25zLltJRF0uZG9jdW1lbnRzXG4gICAgICogLSBkb2N1bWVudHNcbiAgICAgKiAtIGRvY3VtZW50cy5bSURdXG4gICAgICogLSBmaWxlc1xuICAgICAqIC0gZmlsZXMuW0lEXVxuICAgICAqIC0gZXhlY3V0aW9uc1xuICAgICAqIC0gZXhlY3V0aW9ucy5bSURdXG4gICAgICogLSBmdW5jdGlvbnMuW0lEXVxuICAgICAqIC0gdGVhbXNcbiAgICAgKiAtIHRlYW1zLltJRF1cbiAgICAgKiAtIG1lbWJlcnNoaXBzXG4gICAgICogLSBtZW1iZXJzaGlwcy5bSURdXG4gICAgICogQHBhcmFtIHsocGF5bG9hZDogUmVhbHRpbWVNZXNzYWdlKSA9PiB2b2lkfSBjYWxsYmFjayBJcyBjYWxsZWQgb24gZXZlcnkgcmVhbHRpbWUgdXBkYXRlLlxuICAgICAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfSBVbnN1YnNjcmliZXMgZnJvbSBldmVudHMuXG4gICAgICovXG4gICAgc3Vic2NyaWJlKGNoYW5uZWxzLCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgY2hhbm5lbEFycmF5ID0gdHlwZW9mIGNoYW5uZWxzID09PSAnc3RyaW5nJyA/IFtjaGFubmVsc10gOiBjaGFubmVscztcbiAgICAgICAgY2hhbm5lbEFycmF5LmZvckVhY2goY2hhbm5lbCA9PiB0aGlzLnJlYWx0aW1lLmNoYW5uZWxzLmFkZChjaGFubmVsKSk7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSB0aGlzLnJlYWx0aW1lLnN1YnNjcmlwdGlvbnNDb3VudGVyKys7XG4gICAgICAgIHRoaXMucmVhbHRpbWUuc3Vic2NyaXB0aW9ucy5zZXQoY291bnRlciwge1xuICAgICAgICAgICAgY2hhbm5lbHM6IGNoYW5uZWxBcnJheSxcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlYWx0aW1lLmNvbm5lY3QoKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuc3Vic2NyaXB0aW9ucy5kZWxldGUoY291bnRlcik7XG4gICAgICAgICAgICB0aGlzLnJlYWx0aW1lLmNsZWFuVXAoY2hhbm5lbEFycmF5KTtcbiAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuY29ubmVjdCgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBwcmVwYXJlUmVxdWVzdChtZXRob2QsIHVybCwgaGVhZGVycyA9IHt9LCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBtZXRob2QgPSBtZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaGVhZGVycywgaGVhZGVycyk7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYWxTdG9yYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBjb29raWVGYWxsYmFjayA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnY29va2llRmFsbGJhY2snKTtcbiAgICAgICAgICAgIGlmIChjb29raWVGYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbJ1gtRmFsbGJhY2stQ29va2llcyddID0gY29va2llRmFsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaGVhZGVyc1snWC1BcHB3cml0ZS1EZXYtS2V5J10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9ucy5jcmVkZW50aWFscyA9ICdpbmNsdWRlJztcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoQ2xpZW50LmZsYXR0ZW4ocGFyYW1zKSkpIHtcbiAgICAgICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaGVhZGVyc1snY29udGVudC10eXBlJ10pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdhcHBsaWNhdGlvbi9qc29uJzpcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkocGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSc6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCB2YWx1ZSwgdmFsdWUubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmVzdGVkVmFsdWUgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGAke2tleX1bXWAsIG5lc3RlZFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5ib2R5ID0gZm9ybURhdGE7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBoZWFkZXJzWydjb250ZW50LXR5cGUnXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdXJpOiB1cmwudG9TdHJpbmcoKSwgb3B0aW9ucyB9O1xuICAgIH1cbiAgICBjaHVua2VkVXBsb2FkKG1ldGhvZCwgdXJsLCBoZWFkZXJzID0ge30sIG9yaWdpbmFsUGF5bG9hZCA9IHt9LCBvblByb2dyZXNzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IFtmaWxlUGFyYW0sIGZpbGVdID0gKF9hID0gT2JqZWN0LmVudHJpZXMob3JpZ2luYWxQYXlsb2FkKS5maW5kKChbXywgdmFsdWVdKSA9PiB2YWx1ZSBpbnN0YW5jZW9mIEZpbGUpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgICAgIGlmICghZmlsZSB8fCAhZmlsZVBhcmFtKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWxlIG5vdCBmb3VuZCBpbiBwYXlsb2FkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlsZS5zaXplIDw9IENsaWVudC5DSFVOS19TSVpFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2FsbChtZXRob2QsIHVybCwgaGVhZGVycywgb3JpZ2luYWxQYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdGFydCA9IDA7XG4gICAgICAgICAgICBsZXQgcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKHN0YXJ0IDwgZmlsZS5zaXplKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IHN0YXJ0ICsgQ2xpZW50LkNIVU5LX1NJWkU7IC8vIFByZXBhcmUgZW5kIGZvciB0aGUgbmV4dCBjaHVua1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPj0gZmlsZS5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGZpbGUuc2l6ZTsgLy8gQWRqdXN0IGZvciB0aGUgbGFzdCBjaHVuayB0byBpbmNsdWRlIHRoZSBsYXN0IGJ5dGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGVhZGVyc1snY29udGVudC1yYW5nZSddID0gYGJ5dGVzICR7c3RhcnR9LSR7ZW5kIC0gMX0vJHtmaWxlLnNpemV9YDtcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IGZpbGUuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgbGV0IHBheWxvYWQgPSBPYmplY3QuYXNzaWduKHt9LCBvcmlnaW5hbFBheWxvYWQpO1xuICAgICAgICAgICAgICAgIHBheWxvYWRbZmlsZVBhcmFtXSA9IG5ldyBGaWxlKFtjaHVua10sIGZpbGUubmFtZSk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNhbGwobWV0aG9kLCB1cmwsIGhlYWRlcnMsIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGlmIChvblByb2dyZXNzICYmIHR5cGVvZiBvblByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgJGlkOiByZXNwb25zZS4kaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzczogTWF0aC5yb3VuZCgoZW5kIC8gZmlsZS5zaXplKSAqIDEwMCksXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplVXBsb2FkZWQ6IGVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rc1RvdGFsOiBNYXRoLmNlaWwoZmlsZS5zaXplIC8gQ2xpZW50LkNIVU5LX1NJWkUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtzVXBsb2FkZWQ6IE1hdGguY2VpbChlbmQgLyBDbGllbnQuQ0hVTktfU0laRSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS4kaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1sneC1hcHB3cml0ZS1pZCddID0gcmVzcG9uc2UuJGlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBpbmcoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxsKCdHRVQnLCBuZXcgVVJMKHRoaXMuY29uZmlnLmVuZHBvaW50ICsgJy9waW5nJykpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2FsbChtZXRob2QsIHVybCwgaGVhZGVycyA9IHt9LCBwYXJhbXMgPSB7fSwgcmVzcG9uc2VUeXBlID0gJ2pzb24nKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHVyaSwgb3B0aW9ucyB9ID0gdGhpcy5wcmVwYXJlUmVxdWVzdChtZXRob2QsIHVybCwgaGVhZGVycywgcGFyYW1zKTtcbiAgICAgICAgICAgIGxldCBkYXRhID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgZmV0Y2godXJpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIC8vIHR5cGUgb3BhcXVlOiBOby1DT1JTLCBkaWZmZXJlbnQtb3JpZ2luIHJlc3BvbnNlIChDT1JTLWlzc3VlKVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT09ICdvcGFxdWUnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKGBJbnZhbGlkIE9yaWdpbi4gUmVnaXN0ZXIgeW91ciBuZXcgY2xpZW50ICgke3dpbmRvdy5sb2NhdGlvbi5ob3N0fSkgYXMgYSBuZXcgV2ViIHBsYXRmb3JtIG9uIHlvdXIgcHJvamVjdCBjb25zb2xlIGRhc2hib2FyZGAsIDQwMywgXCJmb3JiaWRkZW5cIiwgXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3YXJuaW5ncyA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LWFwcHdyaXRlLXdhcm5pbmcnKTtcbiAgICAgICAgICAgIGlmICh3YXJuaW5ncykge1xuICAgICAgICAgICAgICAgIHdhcm5pbmdzLnNwbGl0KCc7JykuZm9yRWFjaCgod2FybmluZykgPT4gY29uc29sZS53YXJuKCdXYXJuaW5nOiAnICsgd2FybmluZykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChfYSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi9qc29uJykpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0geWllbGQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzcG9uc2VUeXBlID09PSAnYXJyYXlCdWZmZXInKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHlpZWxkIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB5aWVsZCByZXNwb25zZS50ZXh0KClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKDQwMCA8PSByZXNwb25zZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2VUZXh0ID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKCgoX2IgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pbmNsdWRlcygnYXBwbGljYXRpb24vanNvbicpKSB8fCByZXNwb25zZVR5cGUgPT09ICdhcnJheUJ1ZmZlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VUZXh0ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVRleHQgPSBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEubWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5tZXNzYWdlLCByZXNwb25zZS5zdGF0dXMsIGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS50eXBlLCByZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29va2llRmFsbGJhY2sgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnWC1GYWxsYmFjay1Db29raWVzJyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2FsU3RvcmFnZSAmJiBjb29raWVGYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLndhcm4oJ0FwcHdyaXRlIGlzIHVzaW5nIGxvY2FsU3RvcmFnZSBmb3Igc2Vzc2lvbiBtYW5hZ2VtZW50LiBJbmNyZWFzZSB5b3VyIHNlY3VyaXR5IGJ5IGFkZGluZyBhIGN1c3RvbSBkb21haW4gYXMgeW91ciBBUEkgZW5kcG9pbnQuJyk7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKCdjb29raWVGYWxsYmFjaycsIGNvb2tpZUZhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZsYXR0ZW4oZGF0YSwgcHJlZml4ID0gJycpIHtcbiAgICAgICAgbGV0IG91dHB1dCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhkYXRhKSkge1xuICAgICAgICAgICAgbGV0IGZpbmFsS2V5ID0gcHJlZml4ID8gcHJlZml4ICsgJ1snICsga2V5ICsgJ10nIDoga2V5O1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvdXRwdXQpLCBDbGllbnQuZmxhdHRlbih2YWx1ZSwgZmluYWxLZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dFtmaW5hbEtleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbn1cbkNsaWVudC5DSFVOS19TSVpFID0gMTAyNCAqIDEwMjQgKiA1O1xuXG5jbGFzcyBTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIHN0YXRpYyBmbGF0dGVuKGRhdGEsIHByZWZpeCA9ICcnKSB7XG4gICAgICAgIGxldCBvdXRwdXQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZGF0YSkpIHtcbiAgICAgICAgICAgIGxldCBmaW5hbEtleSA9IHByZWZpeCA/IHByZWZpeCArICdbJyArIGtleSArICddJyA6IGtleTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3V0cHV0KSwgU2VydmljZS5mbGF0dGVuKHZhbHVlLCBmaW5hbEtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W2ZpbmFsS2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgc2l6ZSBmb3IgY2h1bmtlZCB1cGxvYWRzIGluIGJ5dGVzLlxuICovXG5TZXJ2aWNlLkNIVU5LX1NJWkUgPSA1ICogMTAyNCAqIDEwMjQ7IC8vIDVNQlxuXG5jbGFzcyBBY2NvdW50IHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWxzLlVzZXI8UHJlZmVyZW5jZXM+Pn1cbiAgICAgKi9cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGNyZWF0ZShwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdXNlcklkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIGVtYWlsOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHBhc3N3b3JkOiByZXN0WzFdLFxuICAgICAgICAgICAgICAgIG5hbWU6IHJlc3RbMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXNlcklkID0gcGFyYW1zLnVzZXJJZDtcbiAgICAgICAgY29uc3QgZW1haWwgPSBwYXJhbXMuZW1haWw7XG4gICAgICAgIGNvbnN0IHBhc3N3b3JkID0gcGFyYW1zLnBhc3N3b3JkO1xuICAgICAgICBjb25zdCBuYW1lID0gcGFyYW1zLm5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImVtYWlsXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudCc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVtYWlsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW1haWwnXSA9IGVtYWlsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZCddID0gcGFzc3dvcmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVFbWFpbChwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZW1haWw6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW1haWwgPSBwYXJhbXMuZW1haWw7XG4gICAgICAgIGNvbnN0IHBhc3N3b3JkID0gcGFyYW1zLnBhc3N3b3JkO1xuICAgICAgICBpZiAodHlwZW9mIGVtYWlsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJlbWFpbFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvZW1haWwnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bhc3N3b3JkJ10gPSBwYXNzd29yZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgbGlzdElkZW50aXRpZXMocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoIXBhcmFtc09yRmlyc3QgfHwgKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHF1ZXJpZXM6IHBhcmFtc09yRmlyc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcXVlcmllcyA9IHBhcmFtcy5xdWVyaWVzO1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L2lkZW50aXRpZXMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgZGVsZXRlSWRlbnRpdHkocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGlkZW50aXR5SWQ6IHBhcmFtc09yRmlyc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWRlbnRpdHlJZCA9IHBhcmFtcy5pZGVudGl0eUlkO1xuICAgICAgICBpZiAodHlwZW9mIGlkZW50aXR5SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImlkZW50aXR5SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvaWRlbnRpdGllcy97aWRlbnRpdHlJZH0nLnJlcGxhY2UoJ3tpZGVudGl0eUlkfScsIGlkZW50aXR5SWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgZW5kcG9pbnQgdG8gY3JlYXRlIGEgSlNPTiBXZWIgVG9rZW4uIFlvdSBjYW4gdXNlIHRoZSByZXN1bHRpbmcgSldUIHRvIGF1dGhlbnRpY2F0ZSBvbiBiZWhhbGYgb2YgdGhlIGN1cnJlbnQgdXNlciB3aGVuIHdvcmtpbmcgd2l0aCB0aGUgQXBwd3JpdGUgc2VydmVyLXNpZGUgQVBJIGFuZCBTREtzLiBUaGUgSldUIHNlY3JldCBpcyB2YWxpZCBmb3IgMTUgbWludXRlcyBmcm9tIGl0cyBjcmVhdGlvbiBhbmQgd2lsbCBiZSBpbnZhbGlkIGlmIHRoZSB1c2VyIHdpbGwgbG9nb3V0IGluIHRoYXQgdGltZSBmcmFtZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVscy5Kd3Q+fVxuICAgICAqL1xuICAgIGNyZWF0ZUpXVCgpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9qd3RzJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBsaXN0TG9ncyhwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICghcGFyYW1zT3JGaXJzdCB8fCAocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgcXVlcmllczogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxdWVyaWVzID0gcGFyYW1zLnF1ZXJpZXM7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbG9ncyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVNRkEocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIG1mYTogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZmEgPSBwYXJhbXMubWZhO1xuICAgICAgICBpZiAodHlwZW9mIG1mYSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibWZhXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYSc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZmEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtZmEnXSA9IG1mYTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgY3JlYXRlTWZhQXV0aGVudGljYXRvcihwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkgJiYgJ3R5cGUnIGluIHBhcmFtc09yRmlyc3QpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlID0gcGFyYW1zLnR5cGU7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidHlwZVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9tZmEvYXV0aGVudGljYXRvcnMve3R5cGV9Jy5yZXBsYWNlKCd7dHlwZX0nLCB0eXBlKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBjcmVhdGVNRkFBdXRoZW50aWNhdG9yKHBhcmFtc09yRmlyc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSAmJiAndHlwZScgaW4gcGFyYW1zT3JGaXJzdCkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBwYXJhbXNPckZpcnN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGUgPSBwYXJhbXMudHlwZTtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0eXBlXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYS9hdXRoZW50aWNhdG9ycy97dHlwZX0nLnJlcGxhY2UoJ3t0eXBlfScsIHR5cGUpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIHVwZGF0ZU1mYUF1dGhlbnRpY2F0b3IocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpICYmICd0eXBlJyBpbiBwYXJhbXNPckZpcnN0KSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgb3RwOiByZXN0WzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGUgPSBwYXJhbXMudHlwZTtcbiAgICAgICAgY29uc3Qgb3RwID0gcGFyYW1zLm90cDtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0eXBlXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG90cCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwib3RwXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYS9hdXRoZW50aWNhdG9ycy97dHlwZX0nLnJlcGxhY2UoJ3t0eXBlfScsIHR5cGUpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygb3RwICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnb3RwJ10gPSBvdHA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVNRkFBdXRoZW50aWNhdG9yKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSAmJiAndHlwZScgaW4gcGFyYW1zT3JGaXJzdCkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIG90cDogcmVzdFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlID0gcGFyYW1zLnR5cGU7XG4gICAgICAgIGNvbnN0IG90cCA9IHBhcmFtcy5vdHA7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidHlwZVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvdHAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm90cFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9tZmEvYXV0aGVudGljYXRvcnMve3R5cGV9Jy5yZXBsYWNlKCd7dHlwZX0nLCB0eXBlKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG90cCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ290cCddID0gb3RwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncHV0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgZGVsZXRlTWZhQXV0aGVudGljYXRvcihwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkgJiYgJ3R5cGUnIGluIHBhcmFtc09yRmlyc3QpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlID0gcGFyYW1zLnR5cGU7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidHlwZVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9tZmEvYXV0aGVudGljYXRvcnMve3R5cGV9Jy5yZXBsYWNlKCd7dHlwZX0nLCB0eXBlKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGRlbGV0ZU1GQUF1dGhlbnRpY2F0b3IocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpICYmICd0eXBlJyBpbiBwYXJhbXNPckZpcnN0KSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHBhcmFtc09yRmlyc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZSA9IHBhcmFtcy50eXBlO1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInR5cGVcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbWZhL2F1dGhlbnRpY2F0b3JzL3t0eXBlfScucmVwbGFjZSgne3R5cGV9JywgdHlwZSk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBjcmVhdGVNZmFDaGFsbGVuZ2UocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpICYmICdmYWN0b3InIGluIHBhcmFtc09yRmlyc3QpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yOiBwYXJhbXNPckZpcnN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZhY3RvciA9IHBhcmFtcy5mYWN0b3I7XG4gICAgICAgIGlmICh0eXBlb2YgZmFjdG9yID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmYWN0b3JcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbWZhL2NoYWxsZW5nZSc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBmYWN0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmYWN0b3InXSA9IGZhY3RvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBjcmVhdGVNRkFDaGFsbGVuZ2UocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpICYmICdmYWN0b3InIGluIHBhcmFtc09yRmlyc3QpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yOiBwYXJhbXNPckZpcnN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZhY3RvciA9IHBhcmFtcy5mYWN0b3I7XG4gICAgICAgIGlmICh0eXBlb2YgZmFjdG9yID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmYWN0b3JcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbWZhL2NoYWxsZW5nZSc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBmYWN0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmYWN0b3InXSA9IGZhY3RvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVNZmFDaGFsbGVuZ2UocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGNoYWxsZW5nZUlkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIG90cDogcmVzdFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGFsbGVuZ2VJZCA9IHBhcmFtcy5jaGFsbGVuZ2VJZDtcbiAgICAgICAgY29uc3Qgb3RwID0gcGFyYW1zLm90cDtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGFsbGVuZ2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY2hhbGxlbmdlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3RwID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJvdHBcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbWZhL2NoYWxsZW5nZSc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGFsbGVuZ2VJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2NoYWxsZW5nZUlkJ10gPSBjaGFsbGVuZ2VJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG90cCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ290cCddID0gb3RwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncHV0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgdXBkYXRlTUZBQ2hhbGxlbmdlKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBjaGFsbGVuZ2VJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBvdHA6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhbGxlbmdlSWQgPSBwYXJhbXMuY2hhbGxlbmdlSWQ7XG4gICAgICAgIGNvbnN0IG90cCA9IHBhcmFtcy5vdHA7XG4gICAgICAgIGlmICh0eXBlb2YgY2hhbGxlbmdlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNoYWxsZW5nZUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG90cCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwib3RwXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYS9jaGFsbGVuZ2UnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgY2hhbGxlbmdlSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydjaGFsbGVuZ2VJZCddID0gY2hhbGxlbmdlSWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvdHAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydvdHAnXSA9IG90cDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgdGhlIGZhY3RvcnMgYXZhaWxhYmxlIG9uIHRoZSBhY2NvdW50IHRvIGJlIHVzZWQgYXMgYSBNRkEgY2hhbGxhbmdlLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWxzLk1mYUZhY3RvcnM+fVxuICAgICAqIEBkZXByZWNhdGVkIFRoaXMgQVBJIGhhcyBiZWVuIGRlcHJlY2F0ZWQgc2luY2UgMS44LjAuIFBsZWFzZSB1c2UgYEFjY291bnQubGlzdE1GQUZhY3RvcnNgIGluc3RlYWQuXG4gICAgICovXG4gICAgbGlzdE1mYUZhY3RvcnMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbWZhL2ZhY3RvcnMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgdGhlIGZhY3RvcnMgYXZhaWxhYmxlIG9uIHRoZSBhY2NvdW50IHRvIGJlIHVzZWQgYXMgYSBNRkEgY2hhbGxhbmdlLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWxzLk1mYUZhY3RvcnM+fVxuICAgICAqL1xuICAgIGxpc3RNRkFGYWN0b3JzKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYS9mYWN0b3JzJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgcmVjb3ZlcnkgY29kZXMgdGhhdCBjYW4gYmUgdXNlZCBhcyBiYWNrdXAgZm9yIE1GQSBmbG93LiBCZWZvcmUgZ2V0dGluZyBjb2RlcywgdGhleSBtdXN0IGJlIGdlbmVyYXRlZCB1c2luZyBbY3JlYXRlTWZhUmVjb3ZlcnlDb2Rlc10oL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjY3JlYXRlTWZhUmVjb3ZlcnlDb2RlcykgbWV0aG9kLiBBbiBPVFAgY2hhbGxlbmdlIGlzIHJlcXVpcmVkIHRvIHJlYWQgcmVjb3ZlcnkgY29kZXMuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbHMuTWZhUmVjb3ZlcnlDb2Rlcz59XG4gICAgICogQGRlcHJlY2F0ZWQgVGhpcyBBUEkgaGFzIGJlZW4gZGVwcmVjYXRlZCBzaW5jZSAxLjguMC4gUGxlYXNlIHVzZSBgQWNjb3VudC5nZXRNRkFSZWNvdmVyeUNvZGVzYCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGdldE1mYVJlY292ZXJ5Q29kZXMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbWZhL3JlY292ZXJ5LWNvZGVzJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgcmVjb3ZlcnkgY29kZXMgdGhhdCBjYW4gYmUgdXNlZCBhcyBiYWNrdXAgZm9yIE1GQSBmbG93LiBCZWZvcmUgZ2V0dGluZyBjb2RlcywgdGhleSBtdXN0IGJlIGdlbmVyYXRlZCB1c2luZyBbY3JlYXRlTWZhUmVjb3ZlcnlDb2Rlc10oL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjY3JlYXRlTWZhUmVjb3ZlcnlDb2RlcykgbWV0aG9kLiBBbiBPVFAgY2hhbGxlbmdlIGlzIHJlcXVpcmVkIHRvIHJlYWQgcmVjb3ZlcnkgY29kZXMuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbHMuTWZhUmVjb3ZlcnlDb2Rlcz59XG4gICAgICovXG4gICAgZ2V0TUZBUmVjb3ZlcnlDb2RlcygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9tZmEvcmVjb3ZlcnktY29kZXMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHJlY292ZXJ5IGNvZGVzIGFzIGJhY2t1cCBmb3IgTUZBIGZsb3cuIEl0J3MgcmVjb21tZW5kZWQgdG8gZ2VuZXJhdGUgYW5kIHNob3cgdGhlbiBpbW1lZGlhdGVseSBhZnRlciB1c2VyIHN1Y2Nlc3NmdWxseSBhZGRzIHRoZWlyIGF1dGhlaHRpY2F0b3IuIFJlY292ZXJ5IGNvZGVzIGNhbiBiZSB1c2VkIGFzIGEgTUZBIHZlcmlmaWNhdGlvbiB0eXBlIGluIFtjcmVhdGVNZmFDaGFsbGVuZ2VdKC9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I2NyZWF0ZU1mYUNoYWxsZW5nZSkgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWxzLk1mYVJlY292ZXJ5Q29kZXM+fVxuICAgICAqIEBkZXByZWNhdGVkIFRoaXMgQVBJIGhhcyBiZWVuIGRlcHJlY2F0ZWQgc2luY2UgMS44LjAuIFBsZWFzZSB1c2UgYEFjY291bnQuY3JlYXRlTUZBUmVjb3ZlcnlDb2Rlc2AgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBjcmVhdGVNZmFSZWNvdmVyeUNvZGVzKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYS9yZWNvdmVyeS1jb2Rlcyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgcmVjb3ZlcnkgY29kZXMgYXMgYmFja3VwIGZvciBNRkEgZmxvdy4gSXQncyByZWNvbW1lbmRlZCB0byBnZW5lcmF0ZSBhbmQgc2hvdyB0aGVuIGltbWVkaWF0ZWx5IGFmdGVyIHVzZXIgc3VjY2Vzc2Z1bGx5IGFkZHMgdGhlaXIgYXV0aGVodGljYXRvci4gUmVjb3ZlcnkgY29kZXMgY2FuIGJlIHVzZWQgYXMgYSBNRkEgdmVyaWZpY2F0aW9uIHR5cGUgaW4gW2NyZWF0ZU1mYUNoYWxsZW5nZV0oL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjY3JlYXRlTWZhQ2hhbGxlbmdlKSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbHMuTWZhUmVjb3ZlcnlDb2Rlcz59XG4gICAgICovXG4gICAgY3JlYXRlTUZBUmVjb3ZlcnlDb2RlcygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9tZmEvcmVjb3ZlcnktY29kZXMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2VuZXJhdGUgcmVjb3ZlcnkgY29kZXMgdGhhdCBjYW4gYmUgdXNlZCBhcyBiYWNrdXAgZm9yIE1GQSBmbG93LiBCZWZvcmUgcmVnZW5lcmF0aW5nIGNvZGVzLCB0aGV5IG11c3QgYmUgZmlyc3QgZ2VuZXJhdGVkIHVzaW5nIFtjcmVhdGVNZmFSZWNvdmVyeUNvZGVzXSgvZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCNjcmVhdGVNZmFSZWNvdmVyeUNvZGVzKSBtZXRob2QuIEFuIE9UUCBjaGFsbGVuZ2UgaXMgcmVxdWlyZWQgdG8gcmVnZW5yZWF0ZSByZWNvdmVyeSBjb2Rlcy5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVscy5NZmFSZWNvdmVyeUNvZGVzPn1cbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIEFQSSBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIDEuOC4wLiBQbGVhc2UgdXNlIGBBY2NvdW50LnVwZGF0ZU1GQVJlY292ZXJ5Q29kZXNgIGluc3RlYWQuXG4gICAgICovXG4gICAgdXBkYXRlTWZhUmVjb3ZlcnlDb2RlcygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9tZmEvcmVjb3ZlcnktY29kZXMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdlbmVyYXRlIHJlY292ZXJ5IGNvZGVzIHRoYXQgY2FuIGJlIHVzZWQgYXMgYmFja3VwIGZvciBNRkEgZmxvdy4gQmVmb3JlIHJlZ2VuZXJhdGluZyBjb2RlcywgdGhleSBtdXN0IGJlIGZpcnN0IGdlbmVyYXRlZCB1c2luZyBbY3JlYXRlTWZhUmVjb3ZlcnlDb2Rlc10oL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjY3JlYXRlTWZhUmVjb3ZlcnlDb2RlcykgbWV0aG9kLiBBbiBPVFAgY2hhbGxlbmdlIGlzIHJlcXVpcmVkIHRvIHJlZ2VucmVhdGUgcmVjb3ZlcnkgY29kZXMuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbHMuTWZhUmVjb3ZlcnlDb2Rlcz59XG4gICAgICovXG4gICAgdXBkYXRlTUZBUmVjb3ZlcnlDb2RlcygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9tZmEvcmVjb3ZlcnktY29kZXMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVOYW1lKHBhcmFtc09yRmlyc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXNPckZpcnN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSBwYXJhbXMubmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJuYW1lXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L25hbWUnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIHVwZGF0ZVBhc3N3b3JkKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBvbGRQYXNzd29yZDogcmVzdFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXNzd29yZCA9IHBhcmFtcy5wYXNzd29yZDtcbiAgICAgICAgY29uc3Qgb2xkUGFzc3dvcmQgPSBwYXJhbXMub2xkUGFzc3dvcmQ7XG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBhc3N3b3JkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Bhc3N3b3JkJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb2xkUGFzc3dvcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydvbGRQYXNzd29yZCddID0gb2xkUGFzc3dvcmQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIHVwZGF0ZVBob25lKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBwaG9uZTogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogcmVzdFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwaG9uZSA9IHBhcmFtcy5waG9uZTtcbiAgICAgICAgY29uc3QgcGFzc3dvcmQgPSBwYXJhbXMucGFzc3dvcmQ7XG4gICAgICAgIGlmICh0eXBlb2YgcGhvbmUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBob25lXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9waG9uZSc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBwaG9uZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bob25lJ10gPSBwaG9uZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHByZWZlcmVuY2VzIGFzIGEga2V5LXZhbHVlIG9iamVjdCBmb3IgdGhlIGN1cnJlbnRseSBsb2dnZWQgaW4gdXNlci5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFByZWZlcmVuY2VzPn1cbiAgICAgKi9cbiAgICBnZXRQcmVmcygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9wcmVmcyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgdXBkYXRlUHJlZnMocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpICYmICdwcmVmcycgaW4gcGFyYW1zT3JGaXJzdCkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBwcmVmczogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmVmcyA9IHBhcmFtcy5wcmVmcztcbiAgICAgICAgaWYgKHR5cGVvZiBwcmVmcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicHJlZnNcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvcHJlZnMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcHJlZnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwcmVmcyddID0gcHJlZnM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGNyZWF0ZVJlY292ZXJ5KHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBlbWFpbDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICB1cmw6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW1haWwgPSBwYXJhbXMuZW1haWw7XG4gICAgICAgIGNvbnN0IHVybCA9IHBhcmFtcy51cmw7XG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImVtYWlsXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHVybCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXJsXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3JlY292ZXJ5JztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGVtYWlsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW1haWwnXSA9IGVtYWlsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdXJsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXJsJ10gPSB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgdXBkYXRlUmVjb3ZlcnkocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHVzZXJJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBzZWNyZXQ6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IHJlc3RbMV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXNlcklkID0gcGFyYW1zLnVzZXJJZDtcbiAgICAgICAgY29uc3Qgc2VjcmV0ID0gcGFyYW1zLnNlY3JldDtcbiAgICAgICAgY29uc3QgcGFzc3dvcmQgPSBwYXJhbXMucGFzc3dvcmQ7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzZWNyZXRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBhc3N3b3JkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3JlY292ZXJ5JztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VjcmV0J10gPSBzZWNyZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bhc3N3b3JkJ10gPSBwYXNzd29yZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGlzdCBvZiBhY3RpdmUgc2Vzc2lvbnMgYWNyb3NzIGRpZmZlcmVudCBkZXZpY2VzIGZvciB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWxzLlNlc3Npb25MaXN0Pn1cbiAgICAgKi9cbiAgICBsaXN0U2Vzc2lvbnMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvc2Vzc2lvbnMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhbGwgc2Vzc2lvbnMgZnJvbSB0aGUgdXNlciBhY2NvdW50IGFuZCByZW1vdmUgYW55IHNlc3Npb25zIGNvb2tpZXMgZnJvbSB0aGUgZW5kIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHt9Pn1cbiAgICAgKi9cbiAgICBkZWxldGVTZXNzaW9ucygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9zZXNzaW9ucyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBhbGxvdyBhIG5ldyB1c2VyIHRvIHJlZ2lzdGVyIGFuIGFub255bW91cyBhY2NvdW50IGluIHlvdXIgcHJvamVjdC4gVGhpcyByb3V0ZSB3aWxsIGFsc28gY3JlYXRlIGEgbmV3IHNlc3Npb24gZm9yIHRoZSB1c2VyLiBUbyBhbGxvdyB0aGUgbmV3IHVzZXIgdG8gY29udmVydCBhbiBhbm9ueW1vdXMgYWNjb3VudCB0byBhIG5vcm1hbCBhY2NvdW50LCB5b3UgbmVlZCB0byB1cGRhdGUgaXRzIFtlbWFpbCBhbmQgcGFzc3dvcmRdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCN1cGRhdGVFbWFpbCkgb3IgY3JlYXRlIGFuIFtPQXV0aDIgc2Vzc2lvbl0oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I0NyZWF0ZU9BdXRoMlNlc3Npb24pLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWxzLlNlc3Npb24+fVxuICAgICAqL1xuICAgIGNyZWF0ZUFub255bW91c1Nlc3Npb24oKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvc2Vzc2lvbnMvYW5vbnltb3VzJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBjcmVhdGVFbWFpbFBhc3N3b3JkU2Vzc2lvbihwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZW1haWw6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW1haWwgPSBwYXJhbXMuZW1haWw7XG4gICAgICAgIGNvbnN0IHBhc3N3b3JkID0gcGFyYW1zLnBhc3N3b3JkO1xuICAgICAgICBpZiAodHlwZW9mIGVtYWlsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJlbWFpbFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvc2Vzc2lvbnMvZW1haWwnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bhc3N3b3JkJ10gPSBwYXNzd29yZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVNYWdpY1VSTFNlc3Npb24ocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHVzZXJJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBzZWNyZXQ6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXNlcklkID0gcGFyYW1zLnVzZXJJZDtcbiAgICAgICAgY29uc3Qgc2VjcmV0ID0gcGFyYW1zLnNlY3JldDtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInNlY3JldFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9zZXNzaW9ucy9tYWdpYy11cmwnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcklkJ10gPSB1c2VySWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWNyZXQnXSA9IHNlY3JldDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGNyZWF0ZU9BdXRoMlNlc3Npb24ocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpICYmICdwcm92aWRlcicgaW4gcGFyYW1zT3JGaXJzdCkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIGZhaWx1cmU6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgc2NvcGVzOiByZXN0WzJdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gcGFyYW1zLnByb3ZpZGVyO1xuICAgICAgICBjb25zdCBzdWNjZXNzID0gcGFyYW1zLnN1Y2Nlc3M7XG4gICAgICAgIGNvbnN0IGZhaWx1cmUgPSBwYXJhbXMuZmFpbHVyZTtcbiAgICAgICAgY29uc3Qgc2NvcGVzID0gcGFyYW1zLnNjb3BlcztcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicHJvdmlkZXJcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvc2Vzc2lvbnMvb2F1dGgyL3twcm92aWRlcn0nLnJlcGxhY2UoJ3twcm92aWRlcn0nLCBwcm92aWRlcik7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdWNjZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc3VjY2VzcyddID0gc3VjY2VzcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZhaWx1cmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmYWlsdXJlJ10gPSBmYWlsdXJlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2NvcGVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2NvcGVzJ10gPSBzY29wZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgcGF5bG9hZFsncHJvamVjdCddID0gdGhpcy5jbGllbnQuY29uZmlnLnByb2plY3Q7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKFNlcnZpY2UuZmxhdHRlbihwYXlsb2FkKSkpIHtcbiAgICAgICAgICAgIHVyaS5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAod2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LmxvY2F0aW9uKSkge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1cmkudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVQaG9uZVNlc3Npb24ocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHVzZXJJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBzZWNyZXQ6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXNlcklkID0gcGFyYW1zLnVzZXJJZDtcbiAgICAgICAgY29uc3Qgc2VjcmV0ID0gcGFyYW1zLnNlY3JldDtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInNlY3JldFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9zZXNzaW9ucy9waG9uZSc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlY3JldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NlY3JldCddID0gc2VjcmV0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncHV0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgY3JlYXRlU2Vzc2lvbihwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdXNlcklkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHNlY3JldDogcmVzdFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1c2VySWQgPSBwYXJhbXMudXNlcklkO1xuICAgICAgICBjb25zdCBzZWNyZXQgPSBwYXJhbXMuc2VjcmV0O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlY3JldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic2VjcmV0XCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Nlc3Npb25zL3Rva2VuJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VjcmV0J10gPSBzZWNyZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgZ2V0U2Vzc2lvbihwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkOiBwYXJhbXNPckZpcnN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlc3Npb25JZCA9IHBhcmFtcy5zZXNzaW9uSWQ7XG4gICAgICAgIGlmICh0eXBlb2Ygc2Vzc2lvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzZXNzaW9uSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvc2Vzc2lvbnMve3Nlc3Npb25JZH0nLnJlcGxhY2UoJ3tzZXNzaW9uSWR9Jywgc2Vzc2lvbklkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVTZXNzaW9uKHBhcmFtc09yRmlyc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQ6IHBhcmFtc09yRmlyc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2Vzc2lvbklkID0gcGFyYW1zLnNlc3Npb25JZDtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXNzaW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInNlc3Npb25JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9zZXNzaW9ucy97c2Vzc2lvbklkfScucmVwbGFjZSgne3Nlc3Npb25JZH0nLCBzZXNzaW9uSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBkZWxldGVTZXNzaW9uKHBhcmFtc09yRmlyc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQ6IHBhcmFtc09yRmlyc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2Vzc2lvbklkID0gcGFyYW1zLnNlc3Npb25JZDtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXNzaW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInNlc3Npb25JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9zZXNzaW9ucy97c2Vzc2lvbklkfScucmVwbGFjZSgne3Nlc3Npb25JZH0nLCBzZXNzaW9uSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmxvY2sgdGhlIGN1cnJlbnRseSBsb2dnZWQgaW4gdXNlciBhY2NvdW50LiBCZWhpbmQgdGhlIHNjZW5lLCB0aGUgdXNlciByZWNvcmQgaXMgbm90IGRlbGV0ZWQgYnV0IHBlcm1hbmVudGx5IGJsb2NrZWQgZnJvbSBhbnkgYWNjZXNzLiBUbyBjb21wbGV0ZWx5IGRlbGV0ZSBhIHVzZXIsIHVzZSB0aGUgVXNlcnMgQVBJIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbHMuVXNlcjxQcmVmZXJlbmNlcz4+fVxuICAgICAqL1xuICAgIHVwZGF0ZVN0YXR1cygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9zdGF0dXMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBjcmVhdGVQdXNoVGFyZ2V0KHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0YXJnZXRJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVySWQ6IHJlc3RbMV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0SWQgPSBwYXJhbXMudGFyZ2V0SWQ7XG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBwYXJhbXMuaWRlbnRpZmllcjtcbiAgICAgICAgY29uc3QgcHJvdmlkZXJJZCA9IHBhcmFtcy5wcm92aWRlcklkO1xuICAgICAgICBpZiAodHlwZW9mIHRhcmdldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0YXJnZXRJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBpZGVudGlmaWVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJpZGVudGlmaWVyXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3RhcmdldHMvcHVzaCc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RhcmdldElkJ10gPSB0YXJnZXRJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGlkZW50aWZpZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydpZGVudGlmaWVyJ10gPSBpZGVudGlmaWVyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Byb3ZpZGVySWQnXSA9IHByb3ZpZGVySWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgdXBkYXRlUHVzaFRhcmdldChwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0SWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgaWRlbnRpZmllcjogcmVzdFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXRJZCA9IHBhcmFtcy50YXJnZXRJZDtcbiAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IHBhcmFtcy5pZGVudGlmaWVyO1xuICAgICAgICBpZiAodHlwZW9mIHRhcmdldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0YXJnZXRJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBpZGVudGlmaWVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJpZGVudGlmaWVyXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3RhcmdldHMve3RhcmdldElkfS9wdXNoJy5yZXBsYWNlKCd7dGFyZ2V0SWR9JywgdGFyZ2V0SWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgaWRlbnRpZmllciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2lkZW50aWZpZXInXSA9IGlkZW50aWZpZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBkZWxldGVQdXNoVGFyZ2V0KHBhcmFtc09yRmlyc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0YXJnZXRJZDogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXRJZCA9IHBhcmFtcy50YXJnZXRJZDtcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGFyZ2V0SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvdGFyZ2V0cy97dGFyZ2V0SWR9L3B1c2gnLnJlcGxhY2UoJ3t0YXJnZXRJZH0nLCB0YXJnZXRJZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBjcmVhdGVFbWFpbFRva2VuKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB1c2VySWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgZW1haWw6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgcGhyYXNlOiByZXN0WzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVzZXJJZCA9IHBhcmFtcy51c2VySWQ7XG4gICAgICAgIGNvbnN0IGVtYWlsID0gcGFyYW1zLmVtYWlsO1xuICAgICAgICBjb25zdCBwaHJhc2UgPSBwYXJhbXMucGhyYXNlO1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVtYWlsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJlbWFpbFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC90b2tlbnMvZW1haWwnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcklkJ10gPSB1c2VySWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VtYWlsJ10gPSBlbWFpbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBocmFzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3BocmFzZSddID0gcGhyYXNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGNyZWF0ZU1hZ2ljVVJMVG9rZW4ocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHVzZXJJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBlbWFpbDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICB1cmw6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgcGhyYXNlOiByZXN0WzJdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVzZXJJZCA9IHBhcmFtcy51c2VySWQ7XG4gICAgICAgIGNvbnN0IGVtYWlsID0gcGFyYW1zLmVtYWlsO1xuICAgICAgICBjb25zdCB1cmwgPSBwYXJhbXMudXJsO1xuICAgICAgICBjb25zdCBwaHJhc2UgPSBwYXJhbXMucGhyYXNlO1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVtYWlsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJlbWFpbFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC90b2tlbnMvbWFnaWMtdXJsJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1cmwnXSA9IHVybDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBocmFzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3BocmFzZSddID0gcGhyYXNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGNyZWF0ZU9BdXRoMlRva2VuKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSAmJiAncHJvdmlkZXInIGluIHBhcmFtc09yRmlyc3QpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogcmVzdFswXSxcbiAgICAgICAgICAgICAgICBmYWlsdXJlOiByZXN0WzFdLFxuICAgICAgICAgICAgICAgIHNjb3BlczogcmVzdFsyXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm92aWRlciA9IHBhcmFtcy5wcm92aWRlcjtcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IHBhcmFtcy5zdWNjZXNzO1xuICAgICAgICBjb25zdCBmYWlsdXJlID0gcGFyYW1zLmZhaWx1cmU7XG4gICAgICAgIGNvbnN0IHNjb3BlcyA9IHBhcmFtcy5zY29wZXM7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInByb3ZpZGVyXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Rva2Vucy9vYXV0aDIve3Byb3ZpZGVyfScucmVwbGFjZSgne3Byb3ZpZGVyfScsIHByb3ZpZGVyKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHN1Y2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzdWNjZXNzJ10gPSBzdWNjZXNzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZmFpbHVyZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2ZhaWx1cmUnXSA9IGZhaWx1cmU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzY29wZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzY29wZXMnXSA9IHNjb3BlcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBwYXlsb2FkWydwcm9qZWN0J10gPSB0aGlzLmNsaWVudC5jb25maWcucHJvamVjdDtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoU2VydmljZS5mbGF0dGVuKHBheWxvYWQpKSkge1xuICAgICAgICAgICAgdXJpLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICh3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cubG9jYXRpb24pKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVyaS50b1N0cmluZygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVyaS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZVBob25lVG9rZW4ocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHVzZXJJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBwaG9uZTogcmVzdFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1c2VySWQgPSBwYXJhbXMudXNlcklkO1xuICAgICAgICBjb25zdCBwaG9uZSA9IHBhcmFtcy5waG9uZTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwaG9uZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGhvbmVcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvdG9rZW5zL3Bob25lJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGhvbmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwaG9uZSddID0gcGhvbmU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgY3JlYXRlVmVyaWZpY2F0aW9uKHBhcmFtc09yRmlyc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB1cmw6IHBhcmFtc09yRmlyc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gcGFyYW1zLnVybDtcbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVybFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC92ZXJpZmljYXRpb24nO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXJsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXJsJ10gPSB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgdXBkYXRlVmVyaWZpY2F0aW9uKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB1c2VySWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgc2VjcmV0OiByZXN0WzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVzZXJJZCA9IHBhcmFtcy51c2VySWQ7XG4gICAgICAgIGNvbnN0IHNlY3JldCA9IHBhcmFtcy5zZWNyZXQ7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzZWNyZXRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvdmVyaWZpY2F0aW9uJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VjcmV0J10gPSBzZWNyZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBzZW5kIGEgdmVyaWZpY2F0aW9uIFNNUyB0byB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyLiBUaGlzIGVuZHBvaW50IGlzIG1lYW50IGZvciB1c2UgYWZ0ZXIgdXBkYXRpbmcgYSB1c2VyJ3MgcGhvbmUgbnVtYmVyIHVzaW5nIHRoZSBbYWNjb3VudFVwZGF0ZVBob25lXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjdXBkYXRlUGhvbmUpIGVuZHBvaW50LiBMZWFybiBtb3JlIGFib3V0IGhvdyB0byBbY29tcGxldGUgdGhlIHZlcmlmaWNhdGlvbiBwcm9jZXNzXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjdXBkYXRlUGhvbmVWZXJpZmljYXRpb24pLiBUaGUgdmVyaWZpY2F0aW9uIGNvZGUgc2VudCB0byB0aGUgdXNlcidzIHBob25lIG51bWJlciBpcyB2YWxpZCBmb3IgMTUgbWludXRlcy5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVscy5Ub2tlbj59XG4gICAgICovXG4gICAgY3JlYXRlUGhvbmVWZXJpZmljYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvdmVyaWZpY2F0aW9uL3Bob25lJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVQaG9uZVZlcmlmaWNhdGlvbihwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdXNlcklkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHNlY3JldDogcmVzdFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1c2VySWQgPSBwYXJhbXMudXNlcklkO1xuICAgICAgICBjb25zdCBzZWNyZXQgPSBwYXJhbXMuc2VjcmV0O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlY3JldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic2VjcmV0XCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3ZlcmlmaWNhdGlvbi9waG9uZSc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlY3JldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NlY3JldCddID0gc2VjcmV0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncHV0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG59XG5cbmNsYXNzIEF2YXRhcnMge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgZ2V0QnJvd3NlcihwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkgJiYgJ2NvZGUnIGluIHBhcmFtc09yRmlyc3QpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY29kZTogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICB3aWR0aDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgcXVhbGl0eTogcmVzdFsyXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2RlID0gcGFyYW1zLmNvZGU7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gcGFyYW1zLndpZHRoO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBwYXJhbXMuaGVpZ2h0O1xuICAgICAgICBjb25zdCBxdWFsaXR5ID0gcGFyYW1zLnF1YWxpdHk7XG4gICAgICAgIGlmICh0eXBlb2YgY29kZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29kZVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYXZhdGFycy9icm93c2Vycy97Y29kZX0nLnJlcGxhY2UoJ3tjb2RlfScsIGNvZGUpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygd2lkdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd3aWR0aCddID0gd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydoZWlnaHQnXSA9IGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHF1YWxpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWFsaXR5J10gPSBxdWFsaXR5O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIHBheWxvYWRbJ3Byb2plY3QnXSA9IHRoaXMuY2xpZW50LmNvbmZpZy5wcm9qZWN0O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhTZXJ2aWNlLmZsYXR0ZW4ocGF5bG9hZCkpKSB7XG4gICAgICAgICAgICB1cmkuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJpLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGdldENyZWRpdENhcmQocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpICYmICdjb2RlJyBpbiBwYXJhbXNPckZpcnN0KSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGNvZGU6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiByZXN0WzFdLFxuICAgICAgICAgICAgICAgIHF1YWxpdHk6IHJlc3RbMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZSA9IHBhcmFtcy5jb2RlO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHBhcmFtcy53aWR0aDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gcGFyYW1zLmhlaWdodDtcbiAgICAgICAgY29uc3QgcXVhbGl0eSA9IHBhcmFtcy5xdWFsaXR5O1xuICAgICAgICBpZiAodHlwZW9mIGNvZGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvZGVcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2F2YXRhcnMvY3JlZGl0LWNhcmRzL3tjb2RlfScucmVwbGFjZSgne2NvZGV9JywgY29kZSk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3dpZHRoJ10gPSB3aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGhlaWdodCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2hlaWdodCddID0gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcXVhbGl0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1YWxpdHknXSA9IHF1YWxpdHk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgcGF5bG9hZFsncHJvamVjdCddID0gdGhpcy5jbGllbnQuY29uZmlnLnByb2plY3Q7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKFNlcnZpY2UuZmxhdHRlbihwYXlsb2FkKSkpIHtcbiAgICAgICAgICAgIHVyaS5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmkudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZ2V0RmF2aWNvbihwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdXJsOiBwYXJhbXNPckZpcnN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybCA9IHBhcmFtcy51cmw7XG4gICAgICAgIGlmICh0eXBlb2YgdXJsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1cmxcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2F2YXRhcnMvZmF2aWNvbic7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1cmwnXSA9IHVybDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBwYXlsb2FkWydwcm9qZWN0J10gPSB0aGlzLmNsaWVudC5jb25maWcucHJvamVjdDtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoU2VydmljZS5mbGF0dGVuKHBheWxvYWQpKSkge1xuICAgICAgICAgICAgdXJpLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVyaS50b1N0cmluZygpO1xuICAgIH1cbiAgICBnZXRGbGFnKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSAmJiAnY29kZScgaW4gcGFyYW1zT3JGaXJzdCkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICBxdWFsaXR5OiByZXN0WzJdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvZGUgPSBwYXJhbXMuY29kZTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBwYXJhbXMud2lkdGg7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHBhcmFtcy5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IHF1YWxpdHkgPSBwYXJhbXMucXVhbGl0eTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2RlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2RlXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hdmF0YXJzL2ZsYWdzL3tjb2RlfScucmVwbGFjZSgne2NvZGV9JywgY29kZSk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3dpZHRoJ10gPSB3aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGhlaWdodCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2hlaWdodCddID0gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcXVhbGl0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1YWxpdHknXSA9IHF1YWxpdHk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgcGF5bG9hZFsncHJvamVjdCddID0gdGhpcy5jbGllbnQuY29uZmlnLnByb2plY3Q7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKFNlcnZpY2UuZmxhdHRlbihwYXlsb2FkKSkpIHtcbiAgICAgICAgICAgIHVyaS5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmkudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZ2V0SW1hZ2UocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHVybDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICB3aWR0aDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHJlc3RbMV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gcGFyYW1zLnVybDtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBwYXJhbXMud2lkdGg7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHBhcmFtcy5oZWlnaHQ7XG4gICAgICAgIGlmICh0eXBlb2YgdXJsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1cmxcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2F2YXRhcnMvaW1hZ2UnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXJsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXJsJ10gPSB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3dpZHRoJ10gPSB3aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGhlaWdodCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2hlaWdodCddID0gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIHBheWxvYWRbJ3Byb2plY3QnXSA9IHRoaXMuY2xpZW50LmNvbmZpZy5wcm9qZWN0O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhTZXJ2aWNlLmZsYXR0ZW4ocGF5bG9hZCkpKSB7XG4gICAgICAgICAgICB1cmkuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJpLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGdldEluaXRpYWxzKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKCFwYXJhbXNPckZpcnN0IHx8IChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiByZXN0WzJdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSBwYXJhbXMubmFtZTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBwYXJhbXMud2lkdGg7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHBhcmFtcy5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IGJhY2tncm91bmQgPSBwYXJhbXMuYmFja2dyb3VuZDtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYXZhdGFycy9pbml0aWFscyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHdpZHRoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnd2lkdGgnXSA9IHdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaGVpZ2h0J10gPSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBiYWNrZ3JvdW5kICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYmFja2dyb3VuZCddID0gYmFja2dyb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBwYXlsb2FkWydwcm9qZWN0J10gPSB0aGlzLmNsaWVudC5jb25maWcucHJvamVjdDtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoU2VydmljZS5mbGF0dGVuKHBheWxvYWQpKSkge1xuICAgICAgICAgICAgdXJpLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVyaS50b1N0cmluZygpO1xuICAgIH1cbiAgICBnZXRRUihwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBzaXplOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICBkb3dubG9hZDogcmVzdFsyXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0ID0gcGFyYW1zLnRleHQ7XG4gICAgICAgIGNvbnN0IHNpemUgPSBwYXJhbXMuc2l6ZTtcbiAgICAgICAgY29uc3QgbWFyZ2luID0gcGFyYW1zLm1hcmdpbjtcbiAgICAgICAgY29uc3QgZG93bmxvYWQgPSBwYXJhbXMuZG93bmxvYWQ7XG4gICAgICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGV4dFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYXZhdGFycy9xcic7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGV4dCddID0gdGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNpemUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzaXplJ10gPSBzaXplO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbWFyZ2luICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbWFyZ2luJ10gPSBtYXJnaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkb3dubG9hZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2Rvd25sb2FkJ10gPSBkb3dubG9hZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBwYXlsb2FkWydwcm9qZWN0J10gPSB0aGlzLmNsaWVudC5jb25maWcucHJvamVjdDtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoU2VydmljZS5mbGF0dGVuKHBheWxvYWQpKSkge1xuICAgICAgICAgICAgdXJpLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVyaS50b1N0cmluZygpO1xuICAgIH1cbn1cblxuY2xhc3MgRGF0YWJhc2VzIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIGxpc3REb2N1bWVudHMocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGRhdGFiYXNlSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbklkOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHF1ZXJpZXM6IHJlc3RbMV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YWJhc2VJZCA9IHBhcmFtcy5kYXRhYmFzZUlkO1xuICAgICAgICBjb25zdCBjb2xsZWN0aW9uSWQgPSBwYXJhbXMuY29sbGVjdGlvbklkO1xuICAgICAgICBjb25zdCBxdWVyaWVzID0gcGFyYW1zLnF1ZXJpZXM7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9kb2N1bWVudHMnLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGNyZWF0ZURvY3VtZW50KHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBkYXRhYmFzZUlkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25JZDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICBkb2N1bWVudElkOiByZXN0WzFdLFxuICAgICAgICAgICAgICAgIGRhdGE6IHJlc3RbMl0sXG4gICAgICAgICAgICAgICAgcGVybWlzc2lvbnM6IHJlc3RbM11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YWJhc2VJZCA9IHBhcmFtcy5kYXRhYmFzZUlkO1xuICAgICAgICBjb25zdCBjb2xsZWN0aW9uSWQgPSBwYXJhbXMuY29sbGVjdGlvbklkO1xuICAgICAgICBjb25zdCBkb2N1bWVudElkID0gcGFyYW1zLmRvY3VtZW50SWQ7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBwYXJhbXMuZGF0YTtcbiAgICAgICAgY29uc3QgcGVybWlzc2lvbnMgPSBwYXJhbXMucGVybWlzc2lvbnM7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkb2N1bWVudElkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vZG9jdW1lbnRzJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudElkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZG9jdW1lbnRJZCddID0gZG9jdW1lbnRJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkYXRhJ10gPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGVybWlzc2lvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwZXJtaXNzaW9ucyddID0gcGVybWlzc2lvbnM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgZ2V0RG9jdW1lbnQocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGRhdGFiYXNlSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbklkOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50SWQ6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgcXVlcmllczogcmVzdFsyXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhYmFzZUlkID0gcGFyYW1zLmRhdGFiYXNlSWQ7XG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb25JZCA9IHBhcmFtcy5jb2xsZWN0aW9uSWQ7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50SWQgPSBwYXJhbXMuZG9jdW1lbnRJZDtcbiAgICAgICAgY29uc3QgcXVlcmllcyA9IHBhcmFtcy5xdWVyaWVzO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZG9jdW1lbnRJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9kb2N1bWVudHMve2RvY3VtZW50SWR9Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCkucmVwbGFjZSgne2RvY3VtZW50SWR9JywgZG9jdW1lbnRJZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cHNlcnREb2N1bWVudChwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZGF0YWJhc2VJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uSWQ6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRJZDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICBkYXRhOiByZXN0WzJdLFxuICAgICAgICAgICAgICAgIHBlcm1pc3Npb25zOiByZXN0WzNdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFiYXNlSWQgPSBwYXJhbXMuZGF0YWJhc2VJZDtcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbklkID0gcGFyYW1zLmNvbGxlY3Rpb25JZDtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRJZCA9IHBhcmFtcy5kb2N1bWVudElkO1xuICAgICAgICBjb25zdCBkYXRhID0gcGFyYW1zLmRhdGE7XG4gICAgICAgIGNvbnN0IHBlcm1pc3Npb25zID0gcGFyYW1zLnBlcm1pc3Npb25zO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZG9jdW1lbnRJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2RvY3VtZW50cy97ZG9jdW1lbnRJZH0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKS5yZXBsYWNlKCd7ZG9jdW1lbnRJZH0nLCBkb2N1bWVudElkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkYXRhJ10gPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGVybWlzc2lvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwZXJtaXNzaW9ucyddID0gcGVybWlzc2lvbnM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVEb2N1bWVudChwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZGF0YWJhc2VJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uSWQ6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRJZDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICBkYXRhOiByZXN0WzJdLFxuICAgICAgICAgICAgICAgIHBlcm1pc3Npb25zOiByZXN0WzNdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFiYXNlSWQgPSBwYXJhbXMuZGF0YWJhc2VJZDtcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbklkID0gcGFyYW1zLmNvbGxlY3Rpb25JZDtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRJZCA9IHBhcmFtcy5kb2N1bWVudElkO1xuICAgICAgICBjb25zdCBkYXRhID0gcGFyYW1zLmRhdGE7XG4gICAgICAgIGNvbnN0IHBlcm1pc3Npb25zID0gcGFyYW1zLnBlcm1pc3Npb25zO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZG9jdW1lbnRJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9kb2N1bWVudHMve2RvY3VtZW50SWR9Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCkucmVwbGFjZSgne2RvY3VtZW50SWR9JywgZG9jdW1lbnRJZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGF0YSddID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBlcm1pc3Npb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGVybWlzc2lvbnMnXSA9IHBlcm1pc3Npb25zO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBkZWxldGVEb2N1bWVudChwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZGF0YWJhc2VJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uSWQ6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRJZDogcmVzdFsxXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhYmFzZUlkID0gcGFyYW1zLmRhdGFiYXNlSWQ7XG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb25JZCA9IHBhcmFtcy5jb2xsZWN0aW9uSWQ7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50SWQgPSBwYXJhbXMuZG9jdW1lbnRJZDtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRvY3VtZW50SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vZG9jdW1lbnRzL3tkb2N1bWVudElkfScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpLnJlcGxhY2UoJ3tkb2N1bWVudElkfScsIGRvY3VtZW50SWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgZGVjcmVtZW50RG9jdW1lbnRBdHRyaWJ1dGUocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGRhdGFiYXNlSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbklkOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50SWQ6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlOiByZXN0WzJdLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN0WzNdLFxuICAgICAgICAgICAgICAgIG1pbjogcmVzdFs0XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhYmFzZUlkID0gcGFyYW1zLmRhdGFiYXNlSWQ7XG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb25JZCA9IHBhcmFtcy5jb2xsZWN0aW9uSWQ7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50SWQgPSBwYXJhbXMuZG9jdW1lbnRJZDtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlID0gcGFyYW1zLmF0dHJpYnV0ZTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXMudmFsdWU7XG4gICAgICAgIGNvbnN0IG1pbiA9IHBhcmFtcy5taW47XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkb2N1bWVudElkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYXR0cmlidXRlXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2RvY3VtZW50cy97ZG9jdW1lbnRJZH0ve2F0dHJpYnV0ZX0vZGVjcmVtZW50Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCkucmVwbGFjZSgne2RvY3VtZW50SWR9JywgZG9jdW1lbnRJZCkucmVwbGFjZSgne2F0dHJpYnV0ZX0nLCBhdHRyaWJ1dGUpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd2YWx1ZSddID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBtaW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtaW4nXSA9IG1pbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgaW5jcmVtZW50RG9jdW1lbnRBdHRyaWJ1dGUocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGRhdGFiYXNlSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbklkOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50SWQ6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlOiByZXN0WzJdLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN0WzNdLFxuICAgICAgICAgICAgICAgIG1heDogcmVzdFs0XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhYmFzZUlkID0gcGFyYW1zLmRhdGFiYXNlSWQ7XG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb25JZCA9IHBhcmFtcy5jb2xsZWN0aW9uSWQ7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50SWQgPSBwYXJhbXMuZG9jdW1lbnRJZDtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlID0gcGFyYW1zLmF0dHJpYnV0ZTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXMudmFsdWU7XG4gICAgICAgIGNvbnN0IG1heCA9IHBhcmFtcy5tYXg7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkb2N1bWVudElkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYXR0cmlidXRlXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2RvY3VtZW50cy97ZG9jdW1lbnRJZH0ve2F0dHJpYnV0ZX0vaW5jcmVtZW50Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCkucmVwbGFjZSgne2RvY3VtZW50SWR9JywgZG9jdW1lbnRJZCkucmVwbGFjZSgne2F0dHJpYnV0ZX0nLCBhdHRyaWJ1dGUpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd2YWx1ZSddID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBtYXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtYXgnXSA9IG1heDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG59XG5cbmNsYXNzIEZ1bmN0aW9ucyB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBsaXN0RXhlY3V0aW9ucyhwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25JZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBxdWVyaWVzOiByZXN0WzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uSWQgPSBwYXJhbXMuZnVuY3Rpb25JZDtcbiAgICAgICAgY29uc3QgcXVlcmllcyA9IHBhcmFtcy5xdWVyaWVzO1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZ1bmN0aW9uSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2Z1bmN0aW9ucy97ZnVuY3Rpb25JZH0vZXhlY3V0aW9ucycucmVwbGFjZSgne2Z1bmN0aW9uSWR9JywgZnVuY3Rpb25JZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBjcmVhdGVFeGVjdXRpb24ocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgYm9keTogcmVzdFswXSxcbiAgICAgICAgICAgICAgICBhc3luYzogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICB4cGF0aDogcmVzdFsyXSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHJlc3RbM10sXG4gICAgICAgICAgICAgICAgaGVhZGVyczogcmVzdFs0XSxcbiAgICAgICAgICAgICAgICBzY2hlZHVsZWRBdDogcmVzdFs1XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmdW5jdGlvbklkID0gcGFyYW1zLmZ1bmN0aW9uSWQ7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBwYXJhbXMuYm9keTtcbiAgICAgICAgY29uc3QgYXN5bmMgPSBwYXJhbXMuYXN5bmM7XG4gICAgICAgIGNvbnN0IHhwYXRoID0gcGFyYW1zLnhwYXRoO1xuICAgICAgICBjb25zdCBtZXRob2QgPSBwYXJhbXMubWV0aG9kO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gcGFyYW1zLmhlYWRlcnM7XG4gICAgICAgIGNvbnN0IHNjaGVkdWxlZEF0ID0gcGFyYW1zLnNjaGVkdWxlZEF0O1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZ1bmN0aW9uSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2Z1bmN0aW9ucy97ZnVuY3Rpb25JZH0vZXhlY3V0aW9ucycucmVwbGFjZSgne2Z1bmN0aW9uSWR9JywgZnVuY3Rpb25JZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYm9keSddID0gYm9keTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGFzeW5jICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXN5bmMnXSA9IGFzeW5jO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgeHBhdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXRoJ10gPSB4cGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ21ldGhvZCddID0gbWV0aG9kO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaGVhZGVycyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2hlYWRlcnMnXSA9IGhlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlZHVsZWRBdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NjaGVkdWxlZEF0J10gPSBzY2hlZHVsZWRBdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBnZXRFeGVjdXRpb24ocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uSWQ6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuY3Rpb25JZCA9IHBhcmFtcy5mdW5jdGlvbklkO1xuICAgICAgICBjb25zdCBleGVjdXRpb25JZCA9IHBhcmFtcy5leGVjdXRpb25JZDtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmdW5jdGlvbklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGV4ZWN1dGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJleGVjdXRpb25JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zL3tmdW5jdGlvbklkfS9leGVjdXRpb25zL3tleGVjdXRpb25JZH0nLnJlcGxhY2UoJ3tmdW5jdGlvbklkfScsIGZ1bmN0aW9uSWQpLnJlcGxhY2UoJ3tleGVjdXRpb25JZH0nLCBleGVjdXRpb25JZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG59XG5cbmNsYXNzIEdyYXBocWwge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgcXVlcnkocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpICYmICdxdWVyeScgaW4gcGFyYW1zT3JGaXJzdCkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBxdWVyeTogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxdWVyeSA9IHBhcmFtcy5xdWVyeTtcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicXVlcnlcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2dyYXBocWwnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcXVlcnkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyeSddID0gcXVlcnk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICd4LXNkay1ncmFwaHFsJzogJ3RydWUnLFxuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBtdXRhdGlvbihwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkgJiYgJ3F1ZXJ5JyBpbiBwYXJhbXNPckZpcnN0KSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHF1ZXJ5OiBwYXJhbXNPckZpcnN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gcGFyYW1zLnF1ZXJ5O1xuICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJxdWVyeVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZ3JhcGhxbC9tdXRhdGlvbic7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyeSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJ5J10gPSBxdWVyeTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ3gtc2RrLWdyYXBocWwnOiAndHJ1ZScsXG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxufVxuXG5jbGFzcyBMb2NhbGUge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHVzZXIgbG9jYXRpb24gYmFzZWQgb24gSVAuIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdXNlciBjb3VudHJ5IGNvZGUsIGNvdW50cnkgbmFtZSwgY29udGluZW50IG5hbWUsIGNvbnRpbmVudCBjb2RlLCBpcCBhZGRyZXNzIGFuZCBzdWdnZXN0ZWQgY3VycmVuY3kuIFlvdSBjYW4gdXNlIHRoZSBsb2NhbGUgaGVhZGVyIHRvIGdldCB0aGUgZGF0YSBpbiBhIHN1cHBvcnRlZCBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqIChbSVAgR2VvbG9jYXRpb24gYnkgREItSVBdKGh0dHBzOi8vZGItaXAuY29tKSlcbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVscy5Mb2NhbGU+fVxuICAgICAqL1xuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbG9jYWxlJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIGFsbCBsb2NhbGUgY29kZXMgaW4gW0lTTyA2MzktMV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9JU09fNjM5LTFfY29kZXMpLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWxzLkxvY2FsZUNvZGVMaXN0Pn1cbiAgICAgKi9cbiAgICBsaXN0Q29kZXMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2xvY2FsZS9jb2Rlcyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBhbGwgY29udGluZW50cy4gWW91IGNhbiB1c2UgdGhlIGxvY2FsZSBoZWFkZXIgdG8gZ2V0IHRoZSBkYXRhIGluIGEgc3VwcG9ydGVkIGxhbmd1YWdlLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWxzLkNvbnRpbmVudExpc3Q+fVxuICAgICAqL1xuICAgIGxpc3RDb250aW5lbnRzKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9sb2NhbGUvY29udGluZW50cyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBhbGwgY291bnRyaWVzLiBZb3UgY2FuIHVzZSB0aGUgbG9jYWxlIGhlYWRlciB0byBnZXQgdGhlIGRhdGEgaW4gYSBzdXBwb3J0ZWQgbGFuZ3VhZ2UuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbHMuQ291bnRyeUxpc3Q+fVxuICAgICAqL1xuICAgIGxpc3RDb3VudHJpZXMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2xvY2FsZS9jb3VudHJpZXMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgYWxsIGNvdW50cmllcyB0aGF0IGFyZSBjdXJyZW50bHkgbWVtYmVycyBvZiB0aGUgRVUuIFlvdSBjYW4gdXNlIHRoZSBsb2NhbGUgaGVhZGVyIHRvIGdldCB0aGUgZGF0YSBpbiBhIHN1cHBvcnRlZCBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVscy5Db3VudHJ5TGlzdD59XG4gICAgICovXG4gICAgbGlzdENvdW50cmllc0VVKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9sb2NhbGUvY291bnRyaWVzL2V1JztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIGFsbCBjb3VudHJpZXMgcGhvbmUgY29kZXMuIFlvdSBjYW4gdXNlIHRoZSBsb2NhbGUgaGVhZGVyIHRvIGdldCB0aGUgZGF0YSBpbiBhIHN1cHBvcnRlZCBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVscy5QaG9uZUxpc3Q+fVxuICAgICAqL1xuICAgIGxpc3RDb3VudHJpZXNQaG9uZXMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2xvY2FsZS9jb3VudHJpZXMvcGhvbmVzJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIGFsbCBjdXJyZW5jaWVzLCBpbmNsdWRpbmcgY3VycmVuY3kgc3ltYm9sLCBuYW1lLCBwbHVyYWwsIGFuZCBkZWNpbWFsIGRpZ2l0cyBmb3IgYWxsIG1ham9yIGFuZCBtaW5vciBjdXJyZW5jaWVzLiBZb3UgY2FuIHVzZSB0aGUgbG9jYWxlIGhlYWRlciB0byBnZXQgdGhlIGRhdGEgaW4gYSBzdXBwb3J0ZWQgbGFuZ3VhZ2UuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbHMuQ3VycmVuY3lMaXN0Pn1cbiAgICAgKi9cbiAgICBsaXN0Q3VycmVuY2llcygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbG9jYWxlL2N1cnJlbmNpZXMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgYWxsIGxhbmd1YWdlcyBjbGFzc2lmaWVkIGJ5IElTTyA2MzktMSBpbmNsdWRpbmcgMi1sZXR0ZXIgY29kZSwgbmFtZSBpbiBFbmdsaXNoLCBhbmQgbmFtZSBpbiB0aGUgcmVzcGVjdGl2ZSBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVscy5MYW5ndWFnZUxpc3Q+fVxuICAgICAqL1xuICAgIGxpc3RMYW5ndWFnZXMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2xvY2FsZS9sYW5ndWFnZXMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxufVxuXG5jbGFzcyBNZXNzYWdpbmcge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgY3JlYXRlU3Vic2NyaWJlcihwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdG9waWNJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVySWQ6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgdGFyZ2V0SWQ6IHJlc3RbMV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9waWNJZCA9IHBhcmFtcy50b3BpY0lkO1xuICAgICAgICBjb25zdCBzdWJzY3JpYmVySWQgPSBwYXJhbXMuc3Vic2NyaWJlcklkO1xuICAgICAgICBjb25zdCB0YXJnZXRJZCA9IHBhcmFtcy50YXJnZXRJZDtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3BpY0lkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0b3BpY0lkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHN1YnNjcmliZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic3Vic2NyaWJlcklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRhcmdldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0YXJnZXRJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3RvcGljcy97dG9waWNJZH0vc3Vic2NyaWJlcnMnLnJlcGxhY2UoJ3t0b3BpY0lkfScsIHRvcGljSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygc3Vic2NyaWJlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc3Vic2NyaWJlcklkJ10gPSBzdWJzY3JpYmVySWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RhcmdldElkJ10gPSB0YXJnZXRJZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBkZWxldGVTdWJzY3JpYmVyKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0b3BpY0lkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZXJJZDogcmVzdFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b3BpY0lkID0gcGFyYW1zLnRvcGljSWQ7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZXJJZCA9IHBhcmFtcy5zdWJzY3JpYmVySWQ7XG4gICAgICAgIGlmICh0eXBlb2YgdG9waWNJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidG9waWNJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzdWJzY3JpYmVySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInN1YnNjcmliZXJJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3RvcGljcy97dG9waWNJZH0vc3Vic2NyaWJlcnMve3N1YnNjcmliZXJJZH0nLnJlcGxhY2UoJ3t0b3BpY0lkfScsIHRvcGljSWQpLnJlcGxhY2UoJ3tzdWJzY3JpYmVySWR9Jywgc3Vic2NyaWJlcklkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxufVxuXG5jbGFzcyBTdG9yYWdlIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIGxpc3RGaWxlcyhwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgYnVja2V0SWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgcXVlcmllczogcmVzdFswXSxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IHJlc3RbMV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVja2V0SWQgPSBwYXJhbXMuYnVja2V0SWQ7XG4gICAgICAgIGNvbnN0IHF1ZXJpZXMgPSBwYXJhbXMucXVlcmllcztcbiAgICAgICAgY29uc3Qgc2VhcmNoID0gcGFyYW1zLnNlYXJjaDtcbiAgICAgICAgaWYgKHR5cGVvZiBidWNrZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYnVja2V0SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3N0b3JhZ2UvYnVja2V0cy97YnVja2V0SWR9L2ZpbGVzJy5yZXBsYWNlKCd7YnVja2V0SWR9JywgYnVja2V0SWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWFyY2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWFyY2gnXSA9IHNlYXJjaDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBjcmVhdGVGaWxlKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgbGV0IG9uUHJvZ3Jlc3M7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgICAgICBvblByb2dyZXNzID0gcGFyYW1zT3JGaXJzdCA9PT0gbnVsbCB8fCBwYXJhbXNPckZpcnN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXNPckZpcnN0Lm9uUHJvZ3Jlc3M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgYnVja2V0SWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgZmlsZUlkOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIGZpbGU6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgcGVybWlzc2lvbnM6IHJlc3RbMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvblByb2dyZXNzID0gcmVzdFszXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWNrZXRJZCA9IHBhcmFtcy5idWNrZXRJZDtcbiAgICAgICAgY29uc3QgZmlsZUlkID0gcGFyYW1zLmZpbGVJZDtcbiAgICAgICAgY29uc3QgZmlsZSA9IHBhcmFtcy5maWxlO1xuICAgICAgICBjb25zdCBwZXJtaXNzaW9ucyA9IHBhcmFtcy5wZXJtaXNzaW9ucztcbiAgICAgICAgaWYgKHR5cGVvZiBidWNrZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYnVja2V0SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmaWxlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZmlsZVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvc3RvcmFnZS9idWNrZXRzL3tidWNrZXRJZH0vZmlsZXMnLnJlcGxhY2UoJ3tidWNrZXRJZH0nLCBidWNrZXRJZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmaWxlSWQnXSA9IGZpbGVJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZpbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmaWxlJ10gPSBmaWxlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGVybWlzc2lvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwZXJtaXNzaW9ucyddID0gcGVybWlzc2lvbnM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jaHVua2VkVXBsb2FkKCdwb3N0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkLCBvblByb2dyZXNzKTtcbiAgICB9XG4gICAgZ2V0RmlsZShwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgYnVja2V0SWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgZmlsZUlkOiByZXN0WzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1Y2tldElkID0gcGFyYW1zLmJ1Y2tldElkO1xuICAgICAgICBjb25zdCBmaWxlSWQgPSBwYXJhbXMuZmlsZUlkO1xuICAgICAgICBpZiAodHlwZW9mIGJ1Y2tldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJidWNrZXRJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZpbGVJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvc3RvcmFnZS9idWNrZXRzL3tidWNrZXRJZH0vZmlsZXMve2ZpbGVJZH0nLnJlcGxhY2UoJ3tidWNrZXRJZH0nLCBidWNrZXRJZCkucmVwbGFjZSgne2ZpbGVJZH0nLCBmaWxlSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIHVwZGF0ZUZpbGUocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGJ1Y2tldElkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIGZpbGVJZDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICBuYW1lOiByZXN0WzFdLFxuICAgICAgICAgICAgICAgIHBlcm1pc3Npb25zOiByZXN0WzJdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1Y2tldElkID0gcGFyYW1zLmJ1Y2tldElkO1xuICAgICAgICBjb25zdCBmaWxlSWQgPSBwYXJhbXMuZmlsZUlkO1xuICAgICAgICBjb25zdCBuYW1lID0gcGFyYW1zLm5hbWU7XG4gICAgICAgIGNvbnN0IHBlcm1pc3Npb25zID0gcGFyYW1zLnBlcm1pc3Npb25zO1xuICAgICAgICBpZiAodHlwZW9mIGJ1Y2tldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJidWNrZXRJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZpbGVJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvc3RvcmFnZS9idWNrZXRzL3tidWNrZXRJZH0vZmlsZXMve2ZpbGVJZH0nLnJlcGxhY2UoJ3tidWNrZXRJZH0nLCBidWNrZXRJZCkucmVwbGFjZSgne2ZpbGVJZH0nLCBmaWxlSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwZXJtaXNzaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Blcm1pc3Npb25zJ10gPSBwZXJtaXNzaW9ucztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGRlbGV0ZUZpbGUocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGJ1Y2tldElkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIGZpbGVJZDogcmVzdFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWNrZXRJZCA9IHBhcmFtcy5idWNrZXRJZDtcbiAgICAgICAgY29uc3QgZmlsZUlkID0gcGFyYW1zLmZpbGVJZDtcbiAgICAgICAgaWYgKHR5cGVvZiBidWNrZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYnVja2V0SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmaWxlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3N0b3JhZ2UvYnVja2V0cy97YnVja2V0SWR9L2ZpbGVzL3tmaWxlSWR9Jy5yZXBsYWNlKCd7YnVja2V0SWR9JywgYnVja2V0SWQpLnJlcGxhY2UoJ3tmaWxlSWR9JywgZmlsZUlkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGdldEZpbGVEb3dubG9hZChwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgYnVja2V0SWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgZmlsZUlkOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHRva2VuOiByZXN0WzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1Y2tldElkID0gcGFyYW1zLmJ1Y2tldElkO1xuICAgICAgICBjb25zdCBmaWxlSWQgPSBwYXJhbXMuZmlsZUlkO1xuICAgICAgICBjb25zdCB0b2tlbiA9IHBhcmFtcy50b2tlbjtcbiAgICAgICAgaWYgKHR5cGVvZiBidWNrZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYnVja2V0SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmaWxlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3N0b3JhZ2UvYnVja2V0cy97YnVja2V0SWR9L2ZpbGVzL3tmaWxlSWR9L2Rvd25sb2FkJy5yZXBsYWNlKCd7YnVja2V0SWR9JywgYnVja2V0SWQpLnJlcGxhY2UoJ3tmaWxlSWR9JywgZmlsZUlkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndG9rZW4nXSA9IHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIHBheWxvYWRbJ3Byb2plY3QnXSA9IHRoaXMuY2xpZW50LmNvbmZpZy5wcm9qZWN0O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhTZXJ2aWNlLmZsYXR0ZW4ocGF5bG9hZCkpKSB7XG4gICAgICAgICAgICB1cmkuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJpLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGdldEZpbGVQcmV2aWV3KHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBidWNrZXRJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBmaWxlSWQ6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiByZXN0WzJdLFxuICAgICAgICAgICAgICAgIGdyYXZpdHk6IHJlc3RbM10sXG4gICAgICAgICAgICAgICAgcXVhbGl0eTogcmVzdFs0XSxcbiAgICAgICAgICAgICAgICBib3JkZXJXaWR0aDogcmVzdFs1XSxcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogcmVzdFs2XSxcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IHJlc3RbN10sXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogcmVzdFs4XSxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogcmVzdFs5XSxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiByZXN0WzEwXSxcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IHJlc3RbMTFdLFxuICAgICAgICAgICAgICAgIHRva2VuOiByZXN0WzEyXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWNrZXRJZCA9IHBhcmFtcy5idWNrZXRJZDtcbiAgICAgICAgY29uc3QgZmlsZUlkID0gcGFyYW1zLmZpbGVJZDtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBwYXJhbXMud2lkdGg7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHBhcmFtcy5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IGdyYXZpdHkgPSBwYXJhbXMuZ3Jhdml0eTtcbiAgICAgICAgY29uc3QgcXVhbGl0eSA9IHBhcmFtcy5xdWFsaXR5O1xuICAgICAgICBjb25zdCBib3JkZXJXaWR0aCA9IHBhcmFtcy5ib3JkZXJXaWR0aDtcbiAgICAgICAgY29uc3QgYm9yZGVyQ29sb3IgPSBwYXJhbXMuYm9yZGVyQ29sb3I7XG4gICAgICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHBhcmFtcy5ib3JkZXJSYWRpdXM7XG4gICAgICAgIGNvbnN0IG9wYWNpdHkgPSBwYXJhbXMub3BhY2l0eTtcbiAgICAgICAgY29uc3Qgcm90YXRpb24gPSBwYXJhbXMucm90YXRpb247XG4gICAgICAgIGNvbnN0IGJhY2tncm91bmQgPSBwYXJhbXMuYmFja2dyb3VuZDtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gcGFyYW1zLm91dHB1dDtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBwYXJhbXMudG9rZW47XG4gICAgICAgIGlmICh0eXBlb2YgYnVja2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImJ1Y2tldElkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZpbGVJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZmlsZUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9zdG9yYWdlL2J1Y2tldHMve2J1Y2tldElkfS9maWxlcy97ZmlsZUlkfS9wcmV2aWV3Jy5yZXBsYWNlKCd7YnVja2V0SWR9JywgYnVja2V0SWQpLnJlcGxhY2UoJ3tmaWxlSWR9JywgZmlsZUlkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHdpZHRoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnd2lkdGgnXSA9IHdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaGVpZ2h0J10gPSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBncmF2aXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZ3Jhdml0eSddID0gZ3Jhdml0eTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHF1YWxpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWFsaXR5J10gPSBxdWFsaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYm9yZGVyV2lkdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydib3JkZXJXaWR0aCddID0gYm9yZGVyV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBib3JkZXJDb2xvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2JvcmRlckNvbG9yJ10gPSBib3JkZXJDb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGJvcmRlclJhZGl1cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2JvcmRlclJhZGl1cyddID0gYm9yZGVyUmFkaXVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ29wYWNpdHknXSA9IG9wYWNpdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByb3RhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JvdGF0aW9uJ10gPSByb3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGJhY2tncm91bmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydiYWNrZ3JvdW5kJ10gPSBiYWNrZ3JvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3V0cHV0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnb3V0cHV0J10gPSBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Rva2VuJ10gPSB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBwYXlsb2FkWydwcm9qZWN0J10gPSB0aGlzLmNsaWVudC5jb25maWcucHJvamVjdDtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoU2VydmljZS5mbGF0dGVuKHBheWxvYWQpKSkge1xuICAgICAgICAgICAgdXJpLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVyaS50b1N0cmluZygpO1xuICAgIH1cbiAgICBnZXRGaWxlVmlldyhwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgYnVja2V0SWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgZmlsZUlkOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHRva2VuOiByZXN0WzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1Y2tldElkID0gcGFyYW1zLmJ1Y2tldElkO1xuICAgICAgICBjb25zdCBmaWxlSWQgPSBwYXJhbXMuZmlsZUlkO1xuICAgICAgICBjb25zdCB0b2tlbiA9IHBhcmFtcy50b2tlbjtcbiAgICAgICAgaWYgKHR5cGVvZiBidWNrZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYnVja2V0SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmaWxlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3N0b3JhZ2UvYnVja2V0cy97YnVja2V0SWR9L2ZpbGVzL3tmaWxlSWR9L3ZpZXcnLnJlcGxhY2UoJ3tidWNrZXRJZH0nLCBidWNrZXRJZCkucmVwbGFjZSgne2ZpbGVJZH0nLCBmaWxlSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0b2tlbiddID0gdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgcGF5bG9hZFsncHJvamVjdCddID0gdGhpcy5jbGllbnQuY29uZmlnLnByb2plY3Q7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKFNlcnZpY2UuZmxhdHRlbihwYXlsb2FkKSkpIHtcbiAgICAgICAgICAgIHVyaS5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmkudG9TdHJpbmcoKTtcbiAgICB9XG59XG5cbmNsYXNzIFRhYmxlc0RCIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIGxpc3RSb3dzKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBkYXRhYmFzZUlkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHRhYmxlSWQ6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgcXVlcmllczogcmVzdFsxXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhYmFzZUlkID0gcGFyYW1zLmRhdGFiYXNlSWQ7XG4gICAgICAgIGNvbnN0IHRhYmxlSWQgPSBwYXJhbXMudGFibGVJZDtcbiAgICAgICAgY29uc3QgcXVlcmllcyA9IHBhcmFtcy5xdWVyaWVzO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGFibGVJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGFibGVJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGFibGVzZGIve2RhdGFiYXNlSWR9L3RhYmxlcy97dGFibGVJZH0vcm93cycucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne3RhYmxlSWR9JywgdGFibGVJZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBjcmVhdGVSb3cocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGRhdGFiYXNlSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgdGFibGVJZDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICByb3dJZDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICBkYXRhOiByZXN0WzJdLFxuICAgICAgICAgICAgICAgIHBlcm1pc3Npb25zOiByZXN0WzNdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFiYXNlSWQgPSBwYXJhbXMuZGF0YWJhc2VJZDtcbiAgICAgICAgY29uc3QgdGFibGVJZCA9IHBhcmFtcy50YWJsZUlkO1xuICAgICAgICBjb25zdCByb3dJZCA9IHBhcmFtcy5yb3dJZDtcbiAgICAgICAgY29uc3QgZGF0YSA9IHBhcmFtcy5kYXRhO1xuICAgICAgICBjb25zdCBwZXJtaXNzaW9ucyA9IHBhcmFtcy5wZXJtaXNzaW9ucztcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRhYmxlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRhYmxlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygcm93SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJvd0lkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RhYmxlc2RiL3tkYXRhYmFzZUlkfS90YWJsZXMve3RhYmxlSWR9L3Jvd3MnLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3t0YWJsZUlkfScsIHRhYmxlSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygcm93SWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyb3dJZCddID0gcm93SWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGF0YSddID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBlcm1pc3Npb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGVybWlzc2lvbnMnXSA9IHBlcm1pc3Npb25zO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGdldFJvdyhwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZGF0YWJhc2VJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICB0YWJsZUlkOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHJvd0lkOiByZXN0WzFdLFxuICAgICAgICAgICAgICAgIHF1ZXJpZXM6IHJlc3RbMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YWJhc2VJZCA9IHBhcmFtcy5kYXRhYmFzZUlkO1xuICAgICAgICBjb25zdCB0YWJsZUlkID0gcGFyYW1zLnRhYmxlSWQ7XG4gICAgICAgIGNvbnN0IHJvd0lkID0gcGFyYW1zLnJvd0lkO1xuICAgICAgICBjb25zdCBxdWVyaWVzID0gcGFyYW1zLnF1ZXJpZXM7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0YWJsZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0YWJsZUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJvd0lkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyb3dJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGFibGVzZGIve2RhdGFiYXNlSWR9L3RhYmxlcy97dGFibGVJZH0vcm93cy97cm93SWR9Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7dGFibGVJZH0nLCB0YWJsZUlkKS5yZXBsYWNlKCd7cm93SWR9Jywgcm93SWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgdXBzZXJ0Um93KHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBkYXRhYmFzZUlkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHRhYmxlSWQ6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgcm93SWQ6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgZGF0YTogcmVzdFsyXSxcbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uczogcmVzdFszXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhYmFzZUlkID0gcGFyYW1zLmRhdGFiYXNlSWQ7XG4gICAgICAgIGNvbnN0IHRhYmxlSWQgPSBwYXJhbXMudGFibGVJZDtcbiAgICAgICAgY29uc3Qgcm93SWQgPSBwYXJhbXMucm93SWQ7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBwYXJhbXMuZGF0YTtcbiAgICAgICAgY29uc3QgcGVybWlzc2lvbnMgPSBwYXJhbXMucGVybWlzc2lvbnM7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0YWJsZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0YWJsZUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJvd0lkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyb3dJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGFibGVzZGIve2RhdGFiYXNlSWR9L3RhYmxlcy97dGFibGVJZH0vcm93cy97cm93SWR9Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7dGFibGVJZH0nLCB0YWJsZUlkKS5yZXBsYWNlKCd7cm93SWR9Jywgcm93SWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RhdGEnXSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwZXJtaXNzaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Blcm1pc3Npb25zJ10gPSBwZXJtaXNzaW9ucztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIHVwZGF0ZVJvdyhwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZGF0YWJhc2VJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICB0YWJsZUlkOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHJvd0lkOiByZXN0WzFdLFxuICAgICAgICAgICAgICAgIGRhdGE6IHJlc3RbMl0sXG4gICAgICAgICAgICAgICAgcGVybWlzc2lvbnM6IHJlc3RbM11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YWJhc2VJZCA9IHBhcmFtcy5kYXRhYmFzZUlkO1xuICAgICAgICBjb25zdCB0YWJsZUlkID0gcGFyYW1zLnRhYmxlSWQ7XG4gICAgICAgIGNvbnN0IHJvd0lkID0gcGFyYW1zLnJvd0lkO1xuICAgICAgICBjb25zdCBkYXRhID0gcGFyYW1zLmRhdGE7XG4gICAgICAgIGNvbnN0IHBlcm1pc3Npb25zID0gcGFyYW1zLnBlcm1pc3Npb25zO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGFibGVJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGFibGVJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByb3dJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicm93SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RhYmxlc2RiL3tkYXRhYmFzZUlkfS90YWJsZXMve3RhYmxlSWR9L3Jvd3Mve3Jvd0lkfScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne3RhYmxlSWR9JywgdGFibGVJZCkucmVwbGFjZSgne3Jvd0lkfScsIHJvd0lkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkYXRhJ10gPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGVybWlzc2lvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwZXJtaXNzaW9ucyddID0gcGVybWlzc2lvbnM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGRlbGV0ZVJvdyhwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZGF0YWJhc2VJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICB0YWJsZUlkOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHJvd0lkOiByZXN0WzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFiYXNlSWQgPSBwYXJhbXMuZGF0YWJhc2VJZDtcbiAgICAgICAgY29uc3QgdGFibGVJZCA9IHBhcmFtcy50YWJsZUlkO1xuICAgICAgICBjb25zdCByb3dJZCA9IHBhcmFtcy5yb3dJZDtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRhYmxlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRhYmxlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygcm93SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJvd0lkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90YWJsZXNkYi97ZGF0YWJhc2VJZH0vdGFibGVzL3t0YWJsZUlkfS9yb3dzL3tyb3dJZH0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3t0YWJsZUlkfScsIHRhYmxlSWQpLnJlcGxhY2UoJ3tyb3dJZH0nLCByb3dJZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBkZWNyZW1lbnRSb3dDb2x1bW4ocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGRhdGFiYXNlSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgdGFibGVJZDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICByb3dJZDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IHJlc3RbMl0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJlc3RbM10sXG4gICAgICAgICAgICAgICAgbWluOiByZXN0WzRdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFiYXNlSWQgPSBwYXJhbXMuZGF0YWJhc2VJZDtcbiAgICAgICAgY29uc3QgdGFibGVJZCA9IHBhcmFtcy50YWJsZUlkO1xuICAgICAgICBjb25zdCByb3dJZCA9IHBhcmFtcy5yb3dJZDtcbiAgICAgICAgY29uc3QgY29sdW1uID0gcGFyYW1zLmNvbHVtbjtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXMudmFsdWU7XG4gICAgICAgIGNvbnN0IG1pbiA9IHBhcmFtcy5taW47XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0YWJsZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0YWJsZUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJvd0lkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyb3dJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb2x1bW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbHVtblwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGFibGVzZGIve2RhdGFiYXNlSWR9L3RhYmxlcy97dGFibGVJZH0vcm93cy97cm93SWR9L3tjb2x1bW59L2RlY3JlbWVudCcucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne3RhYmxlSWR9JywgdGFibGVJZCkucmVwbGFjZSgne3Jvd0lkfScsIHJvd0lkKS5yZXBsYWNlKCd7Y29sdW1ufScsIGNvbHVtbik7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3ZhbHVlJ10gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG1pbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ21pbiddID0gbWluO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBpbmNyZW1lbnRSb3dDb2x1bW4ocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGRhdGFiYXNlSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgdGFibGVJZDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICByb3dJZDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IHJlc3RbMl0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJlc3RbM10sXG4gICAgICAgICAgICAgICAgbWF4OiByZXN0WzRdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFiYXNlSWQgPSBwYXJhbXMuZGF0YWJhc2VJZDtcbiAgICAgICAgY29uc3QgdGFibGVJZCA9IHBhcmFtcy50YWJsZUlkO1xuICAgICAgICBjb25zdCByb3dJZCA9IHBhcmFtcy5yb3dJZDtcbiAgICAgICAgY29uc3QgY29sdW1uID0gcGFyYW1zLmNvbHVtbjtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXMudmFsdWU7XG4gICAgICAgIGNvbnN0IG1heCA9IHBhcmFtcy5tYXg7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0YWJsZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0YWJsZUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJvd0lkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyb3dJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb2x1bW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbHVtblwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGFibGVzZGIve2RhdGFiYXNlSWR9L3RhYmxlcy97dGFibGVJZH0vcm93cy97cm93SWR9L3tjb2x1bW59L2luY3JlbWVudCcucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne3RhYmxlSWR9JywgdGFibGVJZCkucmVwbGFjZSgne3Jvd0lkfScsIHJvd0lkKS5yZXBsYWNlKCd7Y29sdW1ufScsIGNvbHVtbik7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3ZhbHVlJ10gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG1heCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ21heCddID0gbWF4O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbn1cblxuY2xhc3MgVGVhbXMge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgbGlzdChwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICghcGFyYW1zT3JGaXJzdCB8fCAocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgcXVlcmllczogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcXVlcmllcyA9IHBhcmFtcy5xdWVyaWVzO1xuICAgICAgICBjb25zdCBzZWFyY2ggPSBwYXJhbXMuc2VhcmNoO1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlYXJjaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NlYXJjaCddID0gc2VhcmNoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGNyZWF0ZShwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdGVhbUlkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIG5hbWU6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgcm9sZXM6IHJlc3RbMV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGVhbUlkID0gcGFyYW1zLnRlYW1JZDtcbiAgICAgICAgY29uc3QgbmFtZSA9IHBhcmFtcy5uYW1lO1xuICAgICAgICBjb25zdCByb2xlcyA9IHBhcmFtcy5yb2xlcztcbiAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRlYW1JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJuYW1lXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0ZWFtSWQnXSA9IHRlYW1JZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygcm9sZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyb2xlcyddID0gcm9sZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgZ2V0KHBhcmFtc09yRmlyc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0ZWFtSWQ6IHBhcmFtc09yRmlyc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGVhbUlkID0gcGFyYW1zLnRlYW1JZDtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRlYW1JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMve3RlYW1JZH0nLnJlcGxhY2UoJ3t0ZWFtSWR9JywgdGVhbUlkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVOYW1lKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0ZWFtSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgbmFtZTogcmVzdFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZWFtSWQgPSBwYXJhbXMudGVhbUlkO1xuICAgICAgICBjb25zdCBuYW1lID0gcGFyYW1zLm5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgdGVhbUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0ZWFtSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMve3RlYW1JZH0nLnJlcGxhY2UoJ3t0ZWFtSWR9JywgdGVhbUlkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncHV0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgZGVsZXRlKHBhcmFtc09yRmlyc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0ZWFtSWQ6IHBhcmFtc09yRmlyc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGVhbUlkID0gcGFyYW1zLnRlYW1JZDtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRlYW1JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMve3RlYW1JZH0nLnJlcGxhY2UoJ3t0ZWFtSWR9JywgdGVhbUlkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGxpc3RNZW1iZXJzaGlwcyhwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdGVhbUlkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHF1ZXJpZXM6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgc2VhcmNoOiByZXN0WzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRlYW1JZCA9IHBhcmFtcy50ZWFtSWQ7XG4gICAgICAgIGNvbnN0IHF1ZXJpZXMgPSBwYXJhbXMucXVlcmllcztcbiAgICAgICAgY29uc3Qgc2VhcmNoID0gcGFyYW1zLnNlYXJjaDtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRlYW1JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMve3RlYW1JZH0vbWVtYmVyc2hpcHMnLnJlcGxhY2UoJ3t0ZWFtSWR9JywgdGVhbUlkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VhcmNoJ10gPSBzZWFyY2g7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgY3JlYXRlTWVtYmVyc2hpcChwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdGVhbUlkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHJvbGVzOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIGVtYWlsOiByZXN0WzFdLFxuICAgICAgICAgICAgICAgIHVzZXJJZDogcmVzdFsyXSxcbiAgICAgICAgICAgICAgICBwaG9uZTogcmVzdFszXSxcbiAgICAgICAgICAgICAgICB1cmw6IHJlc3RbNF0sXG4gICAgICAgICAgICAgICAgbmFtZTogcmVzdFs1XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZWFtSWQgPSBwYXJhbXMudGVhbUlkO1xuICAgICAgICBjb25zdCByb2xlcyA9IHBhcmFtcy5yb2xlcztcbiAgICAgICAgY29uc3QgZW1haWwgPSBwYXJhbXMuZW1haWw7XG4gICAgICAgIGNvbnN0IHVzZXJJZCA9IHBhcmFtcy51c2VySWQ7XG4gICAgICAgIGNvbnN0IHBob25lID0gcGFyYW1zLnBob25lO1xuICAgICAgICBjb25zdCB1cmwgPSBwYXJhbXMudXJsO1xuICAgICAgICBjb25zdCBuYW1lID0gcGFyYW1zLm5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgdGVhbUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0ZWFtSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygcm9sZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJvbGVzXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcy97dGVhbUlkfS9tZW1iZXJzaGlwcycucmVwbGFjZSgne3RlYW1JZH0nLCB0ZWFtSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBob25lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGhvbmUnXSA9IHBob25lO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygcm9sZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyb2xlcyddID0gcm9sZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1cmwnXSA9IHVybDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGdldE1lbWJlcnNoaXAocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHRlYW1JZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBtZW1iZXJzaGlwSWQ6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGVhbUlkID0gcGFyYW1zLnRlYW1JZDtcbiAgICAgICAgY29uc3QgbWVtYmVyc2hpcElkID0gcGFyYW1zLm1lbWJlcnNoaXBJZDtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRlYW1JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBtZW1iZXJzaGlwSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm1lbWJlcnNoaXBJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMve3RlYW1JZH0vbWVtYmVyc2hpcHMve21lbWJlcnNoaXBJZH0nLnJlcGxhY2UoJ3t0ZWFtSWR9JywgdGVhbUlkKS5yZXBsYWNlKCd7bWVtYmVyc2hpcElkfScsIG1lbWJlcnNoaXBJZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgdXBkYXRlTWVtYmVyc2hpcChwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdGVhbUlkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIG1lbWJlcnNoaXBJZDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICByb2xlczogcmVzdFsxXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZWFtSWQgPSBwYXJhbXMudGVhbUlkO1xuICAgICAgICBjb25zdCBtZW1iZXJzaGlwSWQgPSBwYXJhbXMubWVtYmVyc2hpcElkO1xuICAgICAgICBjb25zdCByb2xlcyA9IHBhcmFtcy5yb2xlcztcbiAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRlYW1JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBtZW1iZXJzaGlwSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm1lbWJlcnNoaXBJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByb2xlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicm9sZXNcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RlYW1zL3t0ZWFtSWR9L21lbWJlcnNoaXBzL3ttZW1iZXJzaGlwSWR9Jy5yZXBsYWNlKCd7dGVhbUlkfScsIHRlYW1JZCkucmVwbGFjZSgne21lbWJlcnNoaXBJZH0nLCBtZW1iZXJzaGlwSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygcm9sZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyb2xlcyddID0gcm9sZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGRlbGV0ZU1lbWJlcnNoaXAocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHRlYW1JZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBtZW1iZXJzaGlwSWQ6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGVhbUlkID0gcGFyYW1zLnRlYW1JZDtcbiAgICAgICAgY29uc3QgbWVtYmVyc2hpcElkID0gcGFyYW1zLm1lbWJlcnNoaXBJZDtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRlYW1JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBtZW1iZXJzaGlwSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm1lbWJlcnNoaXBJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMve3RlYW1JZH0vbWVtYmVyc2hpcHMve21lbWJlcnNoaXBJZH0nLnJlcGxhY2UoJ3t0ZWFtSWR9JywgdGVhbUlkKS5yZXBsYWNlKCd7bWVtYmVyc2hpcElkfScsIG1lbWJlcnNoaXBJZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVNZW1iZXJzaGlwU3RhdHVzKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0ZWFtSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgbWVtYmVyc2hpcElkOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHVzZXJJZDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICBzZWNyZXQ6IHJlc3RbMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGVhbUlkID0gcGFyYW1zLnRlYW1JZDtcbiAgICAgICAgY29uc3QgbWVtYmVyc2hpcElkID0gcGFyYW1zLm1lbWJlcnNoaXBJZDtcbiAgICAgICAgY29uc3QgdXNlcklkID0gcGFyYW1zLnVzZXJJZDtcbiAgICAgICAgY29uc3Qgc2VjcmV0ID0gcGFyYW1zLnNlY3JldDtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRlYW1JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBtZW1iZXJzaGlwSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm1lbWJlcnNoaXBJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInNlY3JldFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMve3RlYW1JZH0vbWVtYmVyc2hpcHMve21lbWJlcnNoaXBJZH0vc3RhdHVzJy5yZXBsYWNlKCd7dGVhbUlkfScsIHRlYW1JZCkucmVwbGFjZSgne21lbWJlcnNoaXBJZH0nLCBtZW1iZXJzaGlwSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcklkJ10gPSB1c2VySWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWNyZXQnXSA9IHNlY3JldDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgZ2V0UHJlZnMocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHRlYW1JZDogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZWFtSWQgPSBwYXJhbXMudGVhbUlkO1xuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcy97dGVhbUlkfS9wcmVmcycucmVwbGFjZSgne3RlYW1JZH0nLCB0ZWFtSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIHVwZGF0ZVByZWZzKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0ZWFtSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgcHJlZnM6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGVhbUlkID0gcGFyYW1zLnRlYW1JZDtcbiAgICAgICAgY29uc3QgcHJlZnMgPSBwYXJhbXMucHJlZnM7XG4gICAgICAgIGlmICh0eXBlb2YgdGVhbUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0ZWFtSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcHJlZnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInByZWZzXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcy97dGVhbUlkfS9wcmVmcycucmVwbGFjZSgne3RlYW1JZH0nLCB0ZWFtSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcHJlZnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwcmVmcyddID0gcHJlZnM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgY2xhc3MgdG8gZ2VuZXJhdGUgcGVybWlzc2lvbiBzdHJpbmdzIGZvciByZXNvdXJjZXMuXG4gKi9cbmNsYXNzIFBlcm1pc3Npb24ge1xufVxuLyoqXG4gKiBHZW5lcmF0ZSByZWFkIHBlcm1pc3Npb24gc3RyaW5nIGZvciB0aGUgcHJvdmlkZWQgcm9sZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9sZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUGVybWlzc2lvbi5yZWFkID0gKHJvbGUpID0+IHtcbiAgICByZXR1cm4gYHJlYWQoXCIke3JvbGV9XCIpYDtcbn07XG4vKipcbiAqIEdlbmVyYXRlIHdyaXRlIHBlcm1pc3Npb24gc3RyaW5nIGZvciB0aGUgcHJvdmlkZWQgcm9sZS5cbiAqXG4gKiBUaGlzIGlzIGFuIGFsaWFzIG9mIHVwZGF0ZSwgZGVsZXRlLCBhbmQgcG9zc2libHkgY3JlYXRlLlxuICogRG9uJ3QgdXNlIHdyaXRlIGluIGNvbWJpbmF0aW9uIHdpdGggdXBkYXRlLCBkZWxldGUsIG9yIGNyZWF0ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9sZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUGVybWlzc2lvbi53cml0ZSA9IChyb2xlKSA9PiB7XG4gICAgcmV0dXJuIGB3cml0ZShcIiR7cm9sZX1cIilgO1xufTtcbi8qKlxuICogR2VuZXJhdGUgY3JlYXRlIHBlcm1pc3Npb24gc3RyaW5nIGZvciB0aGUgcHJvdmlkZWQgcm9sZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9sZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUGVybWlzc2lvbi5jcmVhdGUgPSAocm9sZSkgPT4ge1xuICAgIHJldHVybiBgY3JlYXRlKFwiJHtyb2xlfVwiKWA7XG59O1xuLyoqXG4gKiBHZW5lcmF0ZSB1cGRhdGUgcGVybWlzc2lvbiBzdHJpbmcgZm9yIHRoZSBwcm92aWRlZCByb2xlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByb2xlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5QZXJtaXNzaW9uLnVwZGF0ZSA9IChyb2xlKSA9PiB7XG4gICAgcmV0dXJuIGB1cGRhdGUoXCIke3JvbGV9XCIpYDtcbn07XG4vKipcbiAqIEdlbmVyYXRlIGRlbGV0ZSBwZXJtaXNzaW9uIHN0cmluZyBmb3IgdGhlIHByb3ZpZGVkIHJvbGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJvbGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblBlcm1pc3Npb24uZGVsZXRlID0gKHJvbGUpID0+IHtcbiAgICByZXR1cm4gYGRlbGV0ZShcIiR7cm9sZX1cIilgO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgY2xhc3MgdG8gZ2VuZXJhdGUgcm9sZSBzdHJpbmdzIGZvciBgUGVybWlzc2lvbmAuXG4gKi9cbmNsYXNzIFJvbGUge1xuICAgIC8qKlxuICAgICAqIEdyYW50cyBhY2Nlc3MgdG8gYW55b25lLlxuICAgICAqXG4gICAgICogVGhpcyBpbmNsdWRlcyBhdXRoZW50aWNhdGVkIGFuZCB1bmF1dGhlbnRpY2F0ZWQgdXNlcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyBhbnkoKSB7XG4gICAgICAgIHJldHVybiAnYW55JztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR3JhbnRzIGFjY2VzcyB0byBhIHNwZWNpZmljIHVzZXIgYnkgdXNlciBJRC5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gb3B0aW9uYWxseSBwYXNzIHZlcmlmaWVkIG9yIHVudmVyaWZpZWQgZm9yXG4gICAgICogYHN0YXR1c2AgdG8gdGFyZ2V0IHNwZWNpZmljIHR5cGVzIG9mIHVzZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXR1c1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIHVzZXIoaWQsIHN0YXR1cyA9ICcnKSB7XG4gICAgICAgIGlmIChzdGF0dXMgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gYHVzZXI6JHtpZH1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgdXNlcjoke2lkfS8ke3N0YXR1c31gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHcmFudHMgYWNjZXNzIHRvIGFueSBhdXRoZW50aWNhdGVkIG9yIGFub255bW91cyB1c2VyLlxuICAgICAqXG4gICAgICogWW91IGNhbiBvcHRpb25hbGx5IHBhc3MgdmVyaWZpZWQgb3IgdW52ZXJpZmllZCBmb3JcbiAgICAgKiBgc3RhdHVzYCB0byB0YXJnZXQgc3BlY2lmaWMgdHlwZXMgb2YgdXNlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhdHVzXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgdXNlcnMoc3RhdHVzID0gJycpIHtcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiAndXNlcnMnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgdXNlcnMvJHtzdGF0dXN9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR3JhbnRzIGFjY2VzcyB0byBhbnkgZ3Vlc3QgdXNlciB3aXRob3V0IGEgc2Vzc2lvbi5cbiAgICAgKlxuICAgICAqIEF1dGhlbnRpY2F0ZWQgdXNlcnMgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gdGhpcyByb2xlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgZ3Vlc3RzKCkge1xuICAgICAgICByZXR1cm4gJ2d1ZXN0cyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdyYW50cyBhY2Nlc3MgdG8gYSB0ZWFtIGJ5IHRlYW0gSUQuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIG9wdGlvbmFsbHkgcGFzcyBhIHJvbGUgZm9yIGByb2xlYCB0byB0YXJnZXRcbiAgICAgKiB0ZWFtIG1lbWJlcnMgd2l0aCB0aGUgc3BlY2lmaWVkIHJvbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcm9sZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIHRlYW0oaWQsIHJvbGUgPSAnJykge1xuICAgICAgICBpZiAocm9sZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBgdGVhbToke2lkfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGB0ZWFtOiR7aWR9LyR7cm9sZX1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHcmFudHMgYWNjZXNzIHRvIGEgc3BlY2lmaWMgbWVtYmVyIG9mIGEgdGVhbS5cbiAgICAgKlxuICAgICAqIFdoZW4gdGhlIG1lbWJlciBpcyByZW1vdmVkIGZyb20gdGhlIHRlYW0sIHRoZXkgd2lsbFxuICAgICAqIG5vIGxvbmdlciBoYXZlIGFjY2Vzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIG1lbWJlcihpZCkge1xuICAgICAgICByZXR1cm4gYG1lbWJlcjoke2lkfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdyYW50cyBhY2Nlc3MgdG8gYSB1c2VyIHdpdGggdGhlIHNwZWNpZmllZCBsYWJlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMgIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIGxhYmVsKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGBsYWJlbDoke25hbWV9YDtcbiAgICB9XG59XG5cbnZhciBfYSwgX0lEX2hleFRpbWVzdGFtcDtcbi8qKlxuICogSGVscGVyIGNsYXNzIHRvIGdlbmVyYXRlIElEIHN0cmluZ3MgZm9yIHJlc291cmNlcy5cbiAqL1xuY2xhc3MgSUQge1xuICAgIC8qKlxuICAgICAqIFVzZXMgdGhlIHByb3ZpZGVkIElEIGFzIHRoZSBJRCBmb3IgdGhlIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgY3VzdG9tKGlkKSB7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGF2ZSBBcHB3cml0ZSBnZW5lcmF0ZSBhIHVuaXF1ZSBJRCBmb3IgeW91LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhZGRpbmcuIERlZmF1bHQgaXMgNy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyB1bmlxdWUocGFkZGluZyA9IDcpIHtcbiAgICAgICAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgSUQgd2l0aCBwYWRkaW5nIHRvIGhhdmUgYSBsb25nZXIgSURcbiAgICAgICAgY29uc3QgYmFzZUlkID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldChJRCwgX2EsIFwibVwiLCBfSURfaGV4VGltZXN0YW1wKS5jYWxsKElEKTtcbiAgICAgICAgbGV0IHJhbmRvbVBhZGRpbmcgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWRkaW5nOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJhbmRvbUhleERpZ2l0ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTYpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIHJhbmRvbVBhZGRpbmcgKz0gcmFuZG9tSGV4RGlnaXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VJZCArIHJhbmRvbVBhZGRpbmc7XG4gICAgfVxufVxuX2EgPSBJRCwgX0lEX2hleFRpbWVzdGFtcCA9IGZ1bmN0aW9uIF9JRF9oZXhUaW1lc3RhbXAoKSB7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCBzZWMgPSBNYXRoLmZsb29yKG5vdy5nZXRUaW1lKCkgLyAxMDAwKTtcbiAgICBjb25zdCBtc2VjID0gbm93LmdldE1pbGxpc2Vjb25kcygpO1xuICAgIC8vIENvbnZlcnQgdG8gaGV4YWRlY2ltYWxcbiAgICBjb25zdCBoZXhUaW1lc3RhbXAgPSBzZWMudG9TdHJpbmcoMTYpICsgbXNlYy50b1N0cmluZygxNikucGFkU3RhcnQoNSwgJzAnKTtcbiAgICByZXR1cm4gaGV4VGltZXN0YW1wO1xufTtcblxudmFyIEF1dGhlbnRpY2F0b3JUeXBlO1xuKGZ1bmN0aW9uIChBdXRoZW50aWNhdG9yVHlwZSkge1xuICAgIEF1dGhlbnRpY2F0b3JUeXBlW1wiVG90cFwiXSA9IFwidG90cFwiO1xufSkoQXV0aGVudGljYXRvclR5cGUgfHwgKEF1dGhlbnRpY2F0b3JUeXBlID0ge30pKTtcblxudmFyIEF1dGhlbnRpY2F0aW9uRmFjdG9yO1xuKGZ1bmN0aW9uIChBdXRoZW50aWNhdGlvbkZhY3Rvcikge1xuICAgIEF1dGhlbnRpY2F0aW9uRmFjdG9yW1wiRW1haWxcIl0gPSBcImVtYWlsXCI7XG4gICAgQXV0aGVudGljYXRpb25GYWN0b3JbXCJQaG9uZVwiXSA9IFwicGhvbmVcIjtcbiAgICBBdXRoZW50aWNhdGlvbkZhY3RvcltcIlRvdHBcIl0gPSBcInRvdHBcIjtcbiAgICBBdXRoZW50aWNhdGlvbkZhY3RvcltcIlJlY292ZXJ5Y29kZVwiXSA9IFwicmVjb3Zlcnljb2RlXCI7XG59KShBdXRoZW50aWNhdGlvbkZhY3RvciB8fCAoQXV0aGVudGljYXRpb25GYWN0b3IgPSB7fSkpO1xuXG52YXIgT0F1dGhQcm92aWRlcjtcbihmdW5jdGlvbiAoT0F1dGhQcm92aWRlcikge1xuICAgIE9BdXRoUHJvdmlkZXJbXCJBbWF6b25cIl0gPSBcImFtYXpvblwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJBcHBsZVwiXSA9IFwiYXBwbGVcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiQXV0aDBcIl0gPSBcImF1dGgwXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIkF1dGhlbnRpa1wiXSA9IFwiYXV0aGVudGlrXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIkF1dG9kZXNrXCJdID0gXCJhdXRvZGVza1wiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJCaXRidWNrZXRcIl0gPSBcImJpdGJ1Y2tldFwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJCaXRseVwiXSA9IFwiYml0bHlcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiQm94XCJdID0gXCJib3hcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiRGFpbHltb3Rpb25cIl0gPSBcImRhaWx5bW90aW9uXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIkRpc2NvcmRcIl0gPSBcImRpc2NvcmRcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiRGlzcXVzXCJdID0gXCJkaXNxdXNcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiRHJvcGJveFwiXSA9IFwiZHJvcGJveFwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJFdHN5XCJdID0gXCJldHN5XCI7XG4gICAgT0F1dGhQcm92aWRlcltcIkZhY2Vib29rXCJdID0gXCJmYWNlYm9va1wiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJGaWdtYVwiXSA9IFwiZmlnbWFcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiR2l0aHViXCJdID0gXCJnaXRodWJcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiR2l0bGFiXCJdID0gXCJnaXRsYWJcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiR29vZ2xlXCJdID0gXCJnb29nbGVcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiTGlua2VkaW5cIl0gPSBcImxpbmtlZGluXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIk1pY3Jvc29mdFwiXSA9IFwibWljcm9zb2Z0XCI7XG4gICAgT0F1dGhQcm92aWRlcltcIk5vdGlvblwiXSA9IFwibm90aW9uXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIk9pZGNcIl0gPSBcIm9pZGNcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiT2t0YVwiXSA9IFwib2t0YVwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJQYXlwYWxcIl0gPSBcInBheXBhbFwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJQYXlwYWxTYW5kYm94XCJdID0gXCJwYXlwYWxTYW5kYm94XCI7XG4gICAgT0F1dGhQcm92aWRlcltcIlBvZGlvXCJdID0gXCJwb2Rpb1wiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJTYWxlc2ZvcmNlXCJdID0gXCJzYWxlc2ZvcmNlXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIlNsYWNrXCJdID0gXCJzbGFja1wiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJTcG90aWZ5XCJdID0gXCJzcG90aWZ5XCI7XG4gICAgT0F1dGhQcm92aWRlcltcIlN0cmlwZVwiXSA9IFwic3RyaXBlXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIlRyYWRlc2hpZnRcIl0gPSBcInRyYWRlc2hpZnRcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiVHJhZGVzaGlmdEJveFwiXSA9IFwidHJhZGVzaGlmdEJveFwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJUd2l0Y2hcIl0gPSBcInR3aXRjaFwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJXb3JkcHJlc3NcIl0gPSBcIndvcmRwcmVzc1wiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJZYWhvb1wiXSA9IFwieWFob29cIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiWWFtbWVyXCJdID0gXCJ5YW1tZXJcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiWWFuZGV4XCJdID0gXCJ5YW5kZXhcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiWm9ob1wiXSA9IFwiem9ob1wiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJab29tXCJdID0gXCJ6b29tXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIk1vY2tcIl0gPSBcIm1vY2tcIjtcbn0pKE9BdXRoUHJvdmlkZXIgfHwgKE9BdXRoUHJvdmlkZXIgPSB7fSkpO1xuXG52YXIgQnJvd3NlcjtcbihmdW5jdGlvbiAoQnJvd3Nlcikge1xuICAgIEJyb3dzZXJbXCJBdmFudEJyb3dzZXJcIl0gPSBcImFhXCI7XG4gICAgQnJvd3NlcltcIkFuZHJvaWRXZWJWaWV3QmV0YVwiXSA9IFwiYW5cIjtcbiAgICBCcm93c2VyW1wiR29vZ2xlQ2hyb21lXCJdID0gXCJjaFwiO1xuICAgIEJyb3dzZXJbXCJHb29nbGVDaHJvbWVJT1NcIl0gPSBcImNpXCI7XG4gICAgQnJvd3NlcltcIkdvb2dsZUNocm9tZU1vYmlsZVwiXSA9IFwiY21cIjtcbiAgICBCcm93c2VyW1wiQ2hyb21pdW1cIl0gPSBcImNyXCI7XG4gICAgQnJvd3NlcltcIk1vemlsbGFGaXJlZm94XCJdID0gXCJmZlwiO1xuICAgIEJyb3dzZXJbXCJTYWZhcmlcIl0gPSBcInNmXCI7XG4gICAgQnJvd3NlcltcIk1vYmlsZVNhZmFyaVwiXSA9IFwibWZcIjtcbiAgICBCcm93c2VyW1wiTWljcm9zb2Z0RWRnZVwiXSA9IFwicHNcIjtcbiAgICBCcm93c2VyW1wiTWljcm9zb2Z0RWRnZUlPU1wiXSA9IFwib2lcIjtcbiAgICBCcm93c2VyW1wiT3BlcmFNaW5pXCJdID0gXCJvbVwiO1xuICAgIEJyb3dzZXJbXCJPcGVyYVwiXSA9IFwib3BcIjtcbiAgICBCcm93c2VyW1wiT3BlcmFOZXh0XCJdID0gXCJvblwiO1xufSkoQnJvd3NlciB8fCAoQnJvd3NlciA9IHt9KSk7XG5cbnZhciBDcmVkaXRDYXJkO1xuKGZ1bmN0aW9uIChDcmVkaXRDYXJkKSB7XG4gICAgQ3JlZGl0Q2FyZFtcIkFtZXJpY2FuRXhwcmVzc1wiXSA9IFwiYW1leFwiO1xuICAgIENyZWRpdENhcmRbXCJBcmdlbmNhcmRcIl0gPSBcImFyZ2VuY2FyZFwiO1xuICAgIENyZWRpdENhcmRbXCJDYWJhbFwiXSA9IFwiY2FiYWxcIjtcbiAgICBDcmVkaXRDYXJkW1wiQ2VuY29zdWRcIl0gPSBcImNlbmNvc3VkXCI7XG4gICAgQ3JlZGl0Q2FyZFtcIkRpbmVyc0NsdWJcIl0gPSBcImRpbmVyc1wiO1xuICAgIENyZWRpdENhcmRbXCJEaXNjb3ZlclwiXSA9IFwiZGlzY292ZXJcIjtcbiAgICBDcmVkaXRDYXJkW1wiRWxvXCJdID0gXCJlbG9cIjtcbiAgICBDcmVkaXRDYXJkW1wiSGlwZXJjYXJkXCJdID0gXCJoaXBlcmNhcmRcIjtcbiAgICBDcmVkaXRDYXJkW1wiSkNCXCJdID0gXCJqY2JcIjtcbiAgICBDcmVkaXRDYXJkW1wiTWFzdGVyY2FyZFwiXSA9IFwibWFzdGVyY2FyZFwiO1xuICAgIENyZWRpdENhcmRbXCJOYXJhbmphXCJdID0gXCJuYXJhbmphXCI7XG4gICAgQ3JlZGl0Q2FyZFtcIlRhcmpldGFTaG9wcGluZ1wiXSA9IFwidGFyZ2V0YS1zaG9wcGluZ1wiO1xuICAgIENyZWRpdENhcmRbXCJVbmlvblBheVwiXSA9IFwidW5pb25wYXlcIjtcbiAgICBDcmVkaXRDYXJkW1wiVmlzYVwiXSA9IFwidmlzYVwiO1xuICAgIENyZWRpdENhcmRbXCJNSVJcIl0gPSBcIm1pclwiO1xuICAgIENyZWRpdENhcmRbXCJNYWVzdHJvXCJdID0gXCJtYWVzdHJvXCI7XG4gICAgQ3JlZGl0Q2FyZFtcIlJ1cGF5XCJdID0gXCJydXBheVwiO1xufSkoQ3JlZGl0Q2FyZCB8fCAoQ3JlZGl0Q2FyZCA9IHt9KSk7XG5cbnZhciBGbGFnO1xuKGZ1bmN0aW9uIChGbGFnKSB7XG4gICAgRmxhZ1tcIkFmZ2hhbmlzdGFuXCJdID0gXCJhZlwiO1xuICAgIEZsYWdbXCJBbmdvbGFcIl0gPSBcImFvXCI7XG4gICAgRmxhZ1tcIkFsYmFuaWFcIl0gPSBcImFsXCI7XG4gICAgRmxhZ1tcIkFuZG9ycmFcIl0gPSBcImFkXCI7XG4gICAgRmxhZ1tcIlVuaXRlZEFyYWJFbWlyYXRlc1wiXSA9IFwiYWVcIjtcbiAgICBGbGFnW1wiQXJnZW50aW5hXCJdID0gXCJhclwiO1xuICAgIEZsYWdbXCJBcm1lbmlhXCJdID0gXCJhbVwiO1xuICAgIEZsYWdbXCJBbnRpZ3VhQW5kQmFyYnVkYVwiXSA9IFwiYWdcIjtcbiAgICBGbGFnW1wiQXVzdHJhbGlhXCJdID0gXCJhdVwiO1xuICAgIEZsYWdbXCJBdXN0cmlhXCJdID0gXCJhdFwiO1xuICAgIEZsYWdbXCJBemVyYmFpamFuXCJdID0gXCJhelwiO1xuICAgIEZsYWdbXCJCdXJ1bmRpXCJdID0gXCJiaVwiO1xuICAgIEZsYWdbXCJCZWxnaXVtXCJdID0gXCJiZVwiO1xuICAgIEZsYWdbXCJCZW5pblwiXSA9IFwiYmpcIjtcbiAgICBGbGFnW1wiQnVya2luYUZhc29cIl0gPSBcImJmXCI7XG4gICAgRmxhZ1tcIkJhbmdsYWRlc2hcIl0gPSBcImJkXCI7XG4gICAgRmxhZ1tcIkJ1bGdhcmlhXCJdID0gXCJiZ1wiO1xuICAgIEZsYWdbXCJCYWhyYWluXCJdID0gXCJiaFwiO1xuICAgIEZsYWdbXCJCYWhhbWFzXCJdID0gXCJic1wiO1xuICAgIEZsYWdbXCJCb3NuaWFBbmRIZXJ6ZWdvdmluYVwiXSA9IFwiYmFcIjtcbiAgICBGbGFnW1wiQmVsYXJ1c1wiXSA9IFwiYnlcIjtcbiAgICBGbGFnW1wiQmVsaXplXCJdID0gXCJielwiO1xuICAgIEZsYWdbXCJCb2xpdmlhXCJdID0gXCJib1wiO1xuICAgIEZsYWdbXCJCcmF6aWxcIl0gPSBcImJyXCI7XG4gICAgRmxhZ1tcIkJhcmJhZG9zXCJdID0gXCJiYlwiO1xuICAgIEZsYWdbXCJCcnVuZWlEYXJ1c3NhbGFtXCJdID0gXCJiblwiO1xuICAgIEZsYWdbXCJCaHV0YW5cIl0gPSBcImJ0XCI7XG4gICAgRmxhZ1tcIkJvdHN3YW5hXCJdID0gXCJid1wiO1xuICAgIEZsYWdbXCJDZW50cmFsQWZyaWNhblJlcHVibGljXCJdID0gXCJjZlwiO1xuICAgIEZsYWdbXCJDYW5hZGFcIl0gPSBcImNhXCI7XG4gICAgRmxhZ1tcIlN3aXR6ZXJsYW5kXCJdID0gXCJjaFwiO1xuICAgIEZsYWdbXCJDaGlsZVwiXSA9IFwiY2xcIjtcbiAgICBGbGFnW1wiQ2hpbmFcIl0gPSBcImNuXCI7XG4gICAgRmxhZ1tcIkNvdGVESXZvaXJlXCJdID0gXCJjaVwiO1xuICAgIEZsYWdbXCJDYW1lcm9vblwiXSA9IFwiY21cIjtcbiAgICBGbGFnW1wiRGVtb2NyYXRpY1JlcHVibGljT2ZUaGVDb25nb1wiXSA9IFwiY2RcIjtcbiAgICBGbGFnW1wiUmVwdWJsaWNPZlRoZUNvbmdvXCJdID0gXCJjZ1wiO1xuICAgIEZsYWdbXCJDb2xvbWJpYVwiXSA9IFwiY29cIjtcbiAgICBGbGFnW1wiQ29tb3Jvc1wiXSA9IFwia21cIjtcbiAgICBGbGFnW1wiQ2FwZVZlcmRlXCJdID0gXCJjdlwiO1xuICAgIEZsYWdbXCJDb3N0YVJpY2FcIl0gPSBcImNyXCI7XG4gICAgRmxhZ1tcIkN1YmFcIl0gPSBcImN1XCI7XG4gICAgRmxhZ1tcIkN5cHJ1c1wiXSA9IFwiY3lcIjtcbiAgICBGbGFnW1wiQ3plY2hSZXB1YmxpY1wiXSA9IFwiY3pcIjtcbiAgICBGbGFnW1wiR2VybWFueVwiXSA9IFwiZGVcIjtcbiAgICBGbGFnW1wiRGppYm91dGlcIl0gPSBcImRqXCI7XG4gICAgRmxhZ1tcIkRvbWluaWNhXCJdID0gXCJkbVwiO1xuICAgIEZsYWdbXCJEZW5tYXJrXCJdID0gXCJka1wiO1xuICAgIEZsYWdbXCJEb21pbmljYW5SZXB1YmxpY1wiXSA9IFwiZG9cIjtcbiAgICBGbGFnW1wiQWxnZXJpYVwiXSA9IFwiZHpcIjtcbiAgICBGbGFnW1wiRWN1YWRvclwiXSA9IFwiZWNcIjtcbiAgICBGbGFnW1wiRWd5cHRcIl0gPSBcImVnXCI7XG4gICAgRmxhZ1tcIkVyaXRyZWFcIl0gPSBcImVyXCI7XG4gICAgRmxhZ1tcIlNwYWluXCJdID0gXCJlc1wiO1xuICAgIEZsYWdbXCJFc3RvbmlhXCJdID0gXCJlZVwiO1xuICAgIEZsYWdbXCJFdGhpb3BpYVwiXSA9IFwiZXRcIjtcbiAgICBGbGFnW1wiRmlubGFuZFwiXSA9IFwiZmlcIjtcbiAgICBGbGFnW1wiRmlqaVwiXSA9IFwiZmpcIjtcbiAgICBGbGFnW1wiRnJhbmNlXCJdID0gXCJmclwiO1xuICAgIEZsYWdbXCJNaWNyb25lc2lhRmVkZXJhdGVkU3RhdGVzT2ZcIl0gPSBcImZtXCI7XG4gICAgRmxhZ1tcIkdhYm9uXCJdID0gXCJnYVwiO1xuICAgIEZsYWdbXCJVbml0ZWRLaW5nZG9tXCJdID0gXCJnYlwiO1xuICAgIEZsYWdbXCJHZW9yZ2lhXCJdID0gXCJnZVwiO1xuICAgIEZsYWdbXCJHaGFuYVwiXSA9IFwiZ2hcIjtcbiAgICBGbGFnW1wiR3VpbmVhXCJdID0gXCJnblwiO1xuICAgIEZsYWdbXCJHYW1iaWFcIl0gPSBcImdtXCI7XG4gICAgRmxhZ1tcIkd1aW5lYUJpc3NhdVwiXSA9IFwiZ3dcIjtcbiAgICBGbGFnW1wiRXF1YXRvcmlhbEd1aW5lYVwiXSA9IFwiZ3FcIjtcbiAgICBGbGFnW1wiR3JlZWNlXCJdID0gXCJnclwiO1xuICAgIEZsYWdbXCJHcmVuYWRhXCJdID0gXCJnZFwiO1xuICAgIEZsYWdbXCJHdWF0ZW1hbGFcIl0gPSBcImd0XCI7XG4gICAgRmxhZ1tcIkd1eWFuYVwiXSA9IFwiZ3lcIjtcbiAgICBGbGFnW1wiSG9uZHVyYXNcIl0gPSBcImhuXCI7XG4gICAgRmxhZ1tcIkNyb2F0aWFcIl0gPSBcImhyXCI7XG4gICAgRmxhZ1tcIkhhaXRpXCJdID0gXCJodFwiO1xuICAgIEZsYWdbXCJIdW5nYXJ5XCJdID0gXCJodVwiO1xuICAgIEZsYWdbXCJJbmRvbmVzaWFcIl0gPSBcImlkXCI7XG4gICAgRmxhZ1tcIkluZGlhXCJdID0gXCJpblwiO1xuICAgIEZsYWdbXCJJcmVsYW5kXCJdID0gXCJpZVwiO1xuICAgIEZsYWdbXCJJcmFuSXNsYW1pY1JlcHVibGljT2ZcIl0gPSBcImlyXCI7XG4gICAgRmxhZ1tcIklyYXFcIl0gPSBcImlxXCI7XG4gICAgRmxhZ1tcIkljZWxhbmRcIl0gPSBcImlzXCI7XG4gICAgRmxhZ1tcIklzcmFlbFwiXSA9IFwiaWxcIjtcbiAgICBGbGFnW1wiSXRhbHlcIl0gPSBcIml0XCI7XG4gICAgRmxhZ1tcIkphbWFpY2FcIl0gPSBcImptXCI7XG4gICAgRmxhZ1tcIkpvcmRhblwiXSA9IFwiam9cIjtcbiAgICBGbGFnW1wiSmFwYW5cIl0gPSBcImpwXCI7XG4gICAgRmxhZ1tcIkthemFraHN0YW5cIl0gPSBcImt6XCI7XG4gICAgRmxhZ1tcIktlbnlhXCJdID0gXCJrZVwiO1xuICAgIEZsYWdbXCJLeXJneXpzdGFuXCJdID0gXCJrZ1wiO1xuICAgIEZsYWdbXCJDYW1ib2RpYVwiXSA9IFwia2hcIjtcbiAgICBGbGFnW1wiS2lyaWJhdGlcIl0gPSBcImtpXCI7XG4gICAgRmxhZ1tcIlNhaW50S2l0dHNBbmROZXZpc1wiXSA9IFwia25cIjtcbiAgICBGbGFnW1wiU291dGhLb3JlYVwiXSA9IFwia3JcIjtcbiAgICBGbGFnW1wiS3V3YWl0XCJdID0gXCJrd1wiO1xuICAgIEZsYWdbXCJMYW9QZW9wbGVTRGVtb2NyYXRpY1JlcHVibGljXCJdID0gXCJsYVwiO1xuICAgIEZsYWdbXCJMZWJhbm9uXCJdID0gXCJsYlwiO1xuICAgIEZsYWdbXCJMaWJlcmlhXCJdID0gXCJsclwiO1xuICAgIEZsYWdbXCJMaWJ5YVwiXSA9IFwibHlcIjtcbiAgICBGbGFnW1wiU2FpbnRMdWNpYVwiXSA9IFwibGNcIjtcbiAgICBGbGFnW1wiTGllY2h0ZW5zdGVpblwiXSA9IFwibGlcIjtcbiAgICBGbGFnW1wiU3JpTGFua2FcIl0gPSBcImxrXCI7XG4gICAgRmxhZ1tcIkxlc290aG9cIl0gPSBcImxzXCI7XG4gICAgRmxhZ1tcIkxpdGh1YW5pYVwiXSA9IFwibHRcIjtcbiAgICBGbGFnW1wiTHV4ZW1ib3VyZ1wiXSA9IFwibHVcIjtcbiAgICBGbGFnW1wiTGF0dmlhXCJdID0gXCJsdlwiO1xuICAgIEZsYWdbXCJNb3JvY2NvXCJdID0gXCJtYVwiO1xuICAgIEZsYWdbXCJNb25hY29cIl0gPSBcIm1jXCI7XG4gICAgRmxhZ1tcIk1vbGRvdmFcIl0gPSBcIm1kXCI7XG4gICAgRmxhZ1tcIk1hZGFnYXNjYXJcIl0gPSBcIm1nXCI7XG4gICAgRmxhZ1tcIk1hbGRpdmVzXCJdID0gXCJtdlwiO1xuICAgIEZsYWdbXCJNZXhpY29cIl0gPSBcIm14XCI7XG4gICAgRmxhZ1tcIk1hcnNoYWxsSXNsYW5kc1wiXSA9IFwibWhcIjtcbiAgICBGbGFnW1wiTm9ydGhNYWNlZG9uaWFcIl0gPSBcIm1rXCI7XG4gICAgRmxhZ1tcIk1hbGlcIl0gPSBcIm1sXCI7XG4gICAgRmxhZ1tcIk1hbHRhXCJdID0gXCJtdFwiO1xuICAgIEZsYWdbXCJNeWFubWFyXCJdID0gXCJtbVwiO1xuICAgIEZsYWdbXCJNb250ZW5lZ3JvXCJdID0gXCJtZVwiO1xuICAgIEZsYWdbXCJNb25nb2xpYVwiXSA9IFwibW5cIjtcbiAgICBGbGFnW1wiTW96YW1iaXF1ZVwiXSA9IFwibXpcIjtcbiAgICBGbGFnW1wiTWF1cml0YW5pYVwiXSA9IFwibXJcIjtcbiAgICBGbGFnW1wiTWF1cml0aXVzXCJdID0gXCJtdVwiO1xuICAgIEZsYWdbXCJNYWxhd2lcIl0gPSBcIm13XCI7XG4gICAgRmxhZ1tcIk1hbGF5c2lhXCJdID0gXCJteVwiO1xuICAgIEZsYWdbXCJOYW1pYmlhXCJdID0gXCJuYVwiO1xuICAgIEZsYWdbXCJOaWdlclwiXSA9IFwibmVcIjtcbiAgICBGbGFnW1wiTmlnZXJpYVwiXSA9IFwibmdcIjtcbiAgICBGbGFnW1wiTmljYXJhZ3VhXCJdID0gXCJuaVwiO1xuICAgIEZsYWdbXCJOZXRoZXJsYW5kc1wiXSA9IFwibmxcIjtcbiAgICBGbGFnW1wiTm9yd2F5XCJdID0gXCJub1wiO1xuICAgIEZsYWdbXCJOZXBhbFwiXSA9IFwibnBcIjtcbiAgICBGbGFnW1wiTmF1cnVcIl0gPSBcIm5yXCI7XG4gICAgRmxhZ1tcIk5ld1plYWxhbmRcIl0gPSBcIm56XCI7XG4gICAgRmxhZ1tcIk9tYW5cIl0gPSBcIm9tXCI7XG4gICAgRmxhZ1tcIlBha2lzdGFuXCJdID0gXCJwa1wiO1xuICAgIEZsYWdbXCJQYW5hbWFcIl0gPSBcInBhXCI7XG4gICAgRmxhZ1tcIlBlcnVcIl0gPSBcInBlXCI7XG4gICAgRmxhZ1tcIlBoaWxpcHBpbmVzXCJdID0gXCJwaFwiO1xuICAgIEZsYWdbXCJQYWxhdVwiXSA9IFwicHdcIjtcbiAgICBGbGFnW1wiUGFwdWFOZXdHdWluZWFcIl0gPSBcInBnXCI7XG4gICAgRmxhZ1tcIlBvbGFuZFwiXSA9IFwicGxcIjtcbiAgICBGbGFnW1wiRnJlbmNoUG9seW5lc2lhXCJdID0gXCJwZlwiO1xuICAgIEZsYWdbXCJOb3J0aEtvcmVhXCJdID0gXCJrcFwiO1xuICAgIEZsYWdbXCJQb3J0dWdhbFwiXSA9IFwicHRcIjtcbiAgICBGbGFnW1wiUGFyYWd1YXlcIl0gPSBcInB5XCI7XG4gICAgRmxhZ1tcIlFhdGFyXCJdID0gXCJxYVwiO1xuICAgIEZsYWdbXCJSb21hbmlhXCJdID0gXCJyb1wiO1xuICAgIEZsYWdbXCJSdXNzaWFcIl0gPSBcInJ1XCI7XG4gICAgRmxhZ1tcIlJ3YW5kYVwiXSA9IFwicndcIjtcbiAgICBGbGFnW1wiU2F1ZGlBcmFiaWFcIl0gPSBcInNhXCI7XG4gICAgRmxhZ1tcIlN1ZGFuXCJdID0gXCJzZFwiO1xuICAgIEZsYWdbXCJTZW5lZ2FsXCJdID0gXCJzblwiO1xuICAgIEZsYWdbXCJTaW5nYXBvcmVcIl0gPSBcInNnXCI7XG4gICAgRmxhZ1tcIlNvbG9tb25Jc2xhbmRzXCJdID0gXCJzYlwiO1xuICAgIEZsYWdbXCJTaWVycmFMZW9uZVwiXSA9IFwic2xcIjtcbiAgICBGbGFnW1wiRWxTYWx2YWRvclwiXSA9IFwic3ZcIjtcbiAgICBGbGFnW1wiU2FuTWFyaW5vXCJdID0gXCJzbVwiO1xuICAgIEZsYWdbXCJTb21hbGlhXCJdID0gXCJzb1wiO1xuICAgIEZsYWdbXCJTZXJiaWFcIl0gPSBcInJzXCI7XG4gICAgRmxhZ1tcIlNvdXRoU3VkYW5cIl0gPSBcInNzXCI7XG4gICAgRmxhZ1tcIlNhb1RvbWVBbmRQcmluY2lwZVwiXSA9IFwic3RcIjtcbiAgICBGbGFnW1wiU3VyaW5hbWVcIl0gPSBcInNyXCI7XG4gICAgRmxhZ1tcIlNsb3Zha2lhXCJdID0gXCJza1wiO1xuICAgIEZsYWdbXCJTbG92ZW5pYVwiXSA9IFwic2lcIjtcbiAgICBGbGFnW1wiU3dlZGVuXCJdID0gXCJzZVwiO1xuICAgIEZsYWdbXCJFc3dhdGluaVwiXSA9IFwic3pcIjtcbiAgICBGbGFnW1wiU2V5Y2hlbGxlc1wiXSA9IFwic2NcIjtcbiAgICBGbGFnW1wiU3lyaWFcIl0gPSBcInN5XCI7XG4gICAgRmxhZ1tcIkNoYWRcIl0gPSBcInRkXCI7XG4gICAgRmxhZ1tcIlRvZ29cIl0gPSBcInRnXCI7XG4gICAgRmxhZ1tcIlRoYWlsYW5kXCJdID0gXCJ0aFwiO1xuICAgIEZsYWdbXCJUYWppa2lzdGFuXCJdID0gXCJ0alwiO1xuICAgIEZsYWdbXCJUdXJrbWVuaXN0YW5cIl0gPSBcInRtXCI7XG4gICAgRmxhZ1tcIlRpbW9yTGVzdGVcIl0gPSBcInRsXCI7XG4gICAgRmxhZ1tcIlRvbmdhXCJdID0gXCJ0b1wiO1xuICAgIEZsYWdbXCJUcmluaWRhZEFuZFRvYmFnb1wiXSA9IFwidHRcIjtcbiAgICBGbGFnW1wiVHVuaXNpYVwiXSA9IFwidG5cIjtcbiAgICBGbGFnW1wiVHVya2V5XCJdID0gXCJ0clwiO1xuICAgIEZsYWdbXCJUdXZhbHVcIl0gPSBcInR2XCI7XG4gICAgRmxhZ1tcIlRhbnphbmlhXCJdID0gXCJ0elwiO1xuICAgIEZsYWdbXCJVZ2FuZGFcIl0gPSBcInVnXCI7XG4gICAgRmxhZ1tcIlVrcmFpbmVcIl0gPSBcInVhXCI7XG4gICAgRmxhZ1tcIlVydWd1YXlcIl0gPSBcInV5XCI7XG4gICAgRmxhZ1tcIlVuaXRlZFN0YXRlc1wiXSA9IFwidXNcIjtcbiAgICBGbGFnW1wiVXpiZWtpc3RhblwiXSA9IFwidXpcIjtcbiAgICBGbGFnW1wiVmF0aWNhbkNpdHlcIl0gPSBcInZhXCI7XG4gICAgRmxhZ1tcIlNhaW50VmluY2VudEFuZFRoZUdyZW5hZGluZXNcIl0gPSBcInZjXCI7XG4gICAgRmxhZ1tcIlZlbmV6dWVsYVwiXSA9IFwidmVcIjtcbiAgICBGbGFnW1wiVmlldG5hbVwiXSA9IFwidm5cIjtcbiAgICBGbGFnW1wiVmFudWF0dVwiXSA9IFwidnVcIjtcbiAgICBGbGFnW1wiU2Ftb2FcIl0gPSBcIndzXCI7XG4gICAgRmxhZ1tcIlllbWVuXCJdID0gXCJ5ZVwiO1xuICAgIEZsYWdbXCJTb3V0aEFmcmljYVwiXSA9IFwiemFcIjtcbiAgICBGbGFnW1wiWmFtYmlhXCJdID0gXCJ6bVwiO1xuICAgIEZsYWdbXCJaaW1iYWJ3ZVwiXSA9IFwiendcIjtcbn0pKEZsYWcgfHwgKEZsYWcgPSB7fSkpO1xuXG52YXIgRXhlY3V0aW9uTWV0aG9kO1xuKGZ1bmN0aW9uIChFeGVjdXRpb25NZXRob2QpIHtcbiAgICBFeGVjdXRpb25NZXRob2RbXCJHRVRcIl0gPSBcIkdFVFwiO1xuICAgIEV4ZWN1dGlvbk1ldGhvZFtcIlBPU1RcIl0gPSBcIlBPU1RcIjtcbiAgICBFeGVjdXRpb25NZXRob2RbXCJQVVRcIl0gPSBcIlBVVFwiO1xuICAgIEV4ZWN1dGlvbk1ldGhvZFtcIlBBVENIXCJdID0gXCJQQVRDSFwiO1xuICAgIEV4ZWN1dGlvbk1ldGhvZFtcIkRFTEVURVwiXSA9IFwiREVMRVRFXCI7XG4gICAgRXhlY3V0aW9uTWV0aG9kW1wiT1BUSU9OU1wiXSA9IFwiT1BUSU9OU1wiO1xuICAgIEV4ZWN1dGlvbk1ldGhvZFtcIkhFQURcIl0gPSBcIkhFQURcIjtcbn0pKEV4ZWN1dGlvbk1ldGhvZCB8fCAoRXhlY3V0aW9uTWV0aG9kID0ge30pKTtcblxudmFyIEltYWdlR3Jhdml0eTtcbihmdW5jdGlvbiAoSW1hZ2VHcmF2aXR5KSB7XG4gICAgSW1hZ2VHcmF2aXR5W1wiQ2VudGVyXCJdID0gXCJjZW50ZXJcIjtcbiAgICBJbWFnZUdyYXZpdHlbXCJUb3BsZWZ0XCJdID0gXCJ0b3AtbGVmdFwiO1xuICAgIEltYWdlR3Jhdml0eVtcIlRvcFwiXSA9IFwidG9wXCI7XG4gICAgSW1hZ2VHcmF2aXR5W1wiVG9wcmlnaHRcIl0gPSBcInRvcC1yaWdodFwiO1xuICAgIEltYWdlR3Jhdml0eVtcIkxlZnRcIl0gPSBcImxlZnRcIjtcbiAgICBJbWFnZUdyYXZpdHlbXCJSaWdodFwiXSA9IFwicmlnaHRcIjtcbiAgICBJbWFnZUdyYXZpdHlbXCJCb3R0b21sZWZ0XCJdID0gXCJib3R0b20tbGVmdFwiO1xuICAgIEltYWdlR3Jhdml0eVtcIkJvdHRvbVwiXSA9IFwiYm90dG9tXCI7XG4gICAgSW1hZ2VHcmF2aXR5W1wiQm90dG9tcmlnaHRcIl0gPSBcImJvdHRvbS1yaWdodFwiO1xufSkoSW1hZ2VHcmF2aXR5IHx8IChJbWFnZUdyYXZpdHkgPSB7fSkpO1xuXG52YXIgSW1hZ2VGb3JtYXQ7XG4oZnVuY3Rpb24gKEltYWdlRm9ybWF0KSB7XG4gICAgSW1hZ2VGb3JtYXRbXCJKcGdcIl0gPSBcImpwZ1wiO1xuICAgIEltYWdlRm9ybWF0W1wiSnBlZ1wiXSA9IFwianBlZ1wiO1xuICAgIEltYWdlRm9ybWF0W1wiUG5nXCJdID0gXCJwbmdcIjtcbiAgICBJbWFnZUZvcm1hdFtcIldlYnBcIl0gPSBcIndlYnBcIjtcbiAgICBJbWFnZUZvcm1hdFtcIkhlaWNcIl0gPSBcImhlaWNcIjtcbiAgICBJbWFnZUZvcm1hdFtcIkF2aWZcIl0gPSBcImF2aWZcIjtcbiAgICBJbWFnZUZvcm1hdFtcIkdpZlwiXSA9IFwiZ2lmXCI7XG59KShJbWFnZUZvcm1hdCB8fCAoSW1hZ2VGb3JtYXQgPSB7fSkpO1xuXG5leHBvcnQgeyBBY2NvdW50LCBBcHB3cml0ZUV4Y2VwdGlvbiwgQXV0aGVudGljYXRpb25GYWN0b3IsIEF1dGhlbnRpY2F0b3JUeXBlLCBBdmF0YXJzLCBCcm93c2VyLCBDbGllbnQsIENyZWRpdENhcmQsIERhdGFiYXNlcywgRXhlY3V0aW9uTWV0aG9kLCBGbGFnLCBGdW5jdGlvbnMsIEdyYXBocWwsIElELCBJbWFnZUZvcm1hdCwgSW1hZ2VHcmF2aXR5LCBMb2NhbGUsIE1lc3NhZ2luZywgT0F1dGhQcm92aWRlciwgUGVybWlzc2lvbiwgUXVlcnksIFJvbGUsIFN0b3JhZ2UsIFRhYmxlc0RCLCBUZWFtcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2RrLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/appwrite/dist/esm/sdk.js\n");

/***/ })

};
;